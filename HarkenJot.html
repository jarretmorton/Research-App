<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HarkenJot - Take Notes While You Listen</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // Web Speech API for voice recognition
    // This uses the browser's native speech recognition (Google's service on Chrome/Edge)
    const webSpeechAPI = {
      isReady: false,
      isSupported: false,
      hasNetworkError: false,  // Track if we've had network errors

      init() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        this.isSupported = !!SpeechRecognition;
        this.isReady = this.isSupported;

        if (this.isSupported) {
          console.log('Web Speech API is supported');
        } else {
          console.log('Web Speech API is NOT supported in this browser');
        }

        return this.isSupported;
      },

      createRecognition(options = {}) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          throw new Error('Web Speech API not supported');
        }

        const recognition = new SpeechRecognition();
        recognition.continuous = options.continuous ?? false;
        recognition.interimResults = options.interimResults ?? true;
        recognition.lang = options.lang ?? 'en-US';
        recognition.maxAlternatives = options.maxAlternatives ?? 1;

        return recognition;
      },

      markNetworkError() {
        this.hasNetworkError = true;
        console.log('Web Speech API marked as having network error - will suggest Whisper fallback');
      }
    };

    // Initialize and make globally available
    webSpeechAPI.init();
    window.WebSpeechAPI = webSpeechAPI;
    console.log('WebSpeechAPI initialized, supported:', webSpeechAPI.isSupported);
  </script>
  <script>
    // Whisper Speech Recognition using Transformers.js (fallback for when Web Speech API fails)
    // Uses dynamic import to avoid blocking page load if the CDN is unreachable
    (function() {
      let whisperPipeline = null;
      let isLoadingModel = false;
      let transformersModule = null;

      const whisperASR = {
        isReady: false,
        isLoading: false,
        progress: 0,
        error: null,
        available: true, // Will be set to false if module fails to load

        async loadModel(onProgress) {
          if (whisperPipeline) {
            this.isReady = true;
            return true;
          }
          if (isLoadingModel) return false;

          isLoadingModel = true;
          this.isLoading = true;
          this.error = null;

          try {
            // Dynamically import transformers.js only when needed
            if (!transformersModule) {
              console.log('Loading Transformers.js module...');
              transformersModule = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1');
              transformersModule.env.allowLocalModels = false;
              console.log('Transformers.js module loaded');
            }

            console.log('Loading Whisper model...');
            whisperPipeline = await transformersModule.pipeline(
              'automatic-speech-recognition',
              'Xenova/whisper-tiny.en',
              {
                progress_callback: (progress) => {
                  if (progress.status === 'progress') {
                    this.progress = Math.round(progress.progress);
                    if (onProgress) onProgress(this.progress);
                  }
                  console.log('Model load progress:', progress);
                }
              }
            );
            console.log('Whisper model loaded successfully');
            this.isReady = true;
            this.isLoading = false;
            isLoadingModel = false;
            return true;
          } catch (error) {
            console.error('Failed to load Whisper model:', error);
            this.error = error.message;
            this.isLoading = false;
            isLoadingModel = false;
            return false;
          }
        },

        async transcribe(audioBlob) {
          if (!whisperPipeline) {
            throw new Error('Whisper model not loaded');
          }

          try {
            console.log('Transcribing audio...', audioBlob.size, 'bytes, type:', audioBlob.type);

            // Decode audio blob to raw audio samples using Web Audio API
            const arrayBuffer = await audioBlob.arrayBuffer();
            console.log('ArrayBuffer size:', arrayBuffer.byteLength);

            // Try different sample rates - some browsers need native rate first
            let audioContext;
            let audioBuffer;

            try {
              audioContext = new (window.AudioContext || window.webkitAudioContext)();
              if (audioContext.state === 'suspended') {
                await audioContext.resume();
              }
              audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
              console.log('Decoded at native rate:', audioBuffer.sampleRate, 'Hz');
            } catch (e) {
              console.log('Native decode failed, trying 16kHz:', e.message);
              if (audioContext) await audioContext.close().catch(() => {});
              audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
              if (audioContext.state === 'suspended') {
                await audioContext.resume();
              }
              audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
            }

            // Get audio data as Float32Array (mono for Whisper)
            let audioData;
            if (audioBuffer.numberOfChannels > 1) {
              const left = audioBuffer.getChannelData(0);
              const right = audioBuffer.getChannelData(1);
              audioData = new Float32Array(left.length);
              for (let i = 0; i < left.length; i++) {
                audioData[i] = (left[i] + right[i]) / 2;
              }
            } else {
              audioData = audioBuffer.getChannelData(0);
            }

            // Resample to 16kHz if needed (Whisper requires 16kHz)
            if (audioBuffer.sampleRate !== 16000) {
              console.log('Resampling from', audioBuffer.sampleRate, 'to 16000 Hz');
              const ratio = audioBuffer.sampleRate / 16000;
              const newLength = Math.round(audioData.length / ratio);
              const resampled = new Float32Array(newLength);
              for (let i = 0; i < newLength; i++) {
                const srcIndex = Math.floor(i * ratio);
                resampled[i] = audioData[srcIndex];
              }
              audioData = resampled;
            }

            console.log('Audio ready:', audioData.length, 'samples at 16kHz');

            if (audioData.length < 1600) {
              throw new Error('Audio too short');
            }

            const result = await whisperPipeline(audioData, {
              chunk_length_s: 30,
              stride_length_s: 5,
              language: 'english',
              task: 'transcribe',
              sampling_rate: 16000,
            });
            console.log('Transcription result:', result);
            await audioContext.close();
            return result.text || '';
          } catch (error) {
            console.error('Transcription error:', error);
            throw error;
          }
        },

        getSupportedMimeType() {
          const types = [
            'audio/webm;codecs=opus',
            'audio/webm',
            'audio/mp4',
            'audio/ogg;codecs=opus',
            'audio/ogg',
            'audio/wav',
            'audio/mpeg',
            ''
          ];
          for (const type of types) {
            if (type === '' || MediaRecorder.isTypeSupported(type)) {
              console.log('Using audio format:', type || 'browser default');
              return type;
            }
          }
          return '';
        }
      };

      // Make it globally available
      window.WhisperASR = whisperASR;
      console.log('WhisperASR fallback initialized (lazy-loading enabled)');
    })();
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,500;0,600;1,400&family=DM+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #faf8f5;
      --bg-secondary: #f4f1eb;
      --bg-tertiary: #ebe7df;
      --text-primary: #2d2a26;
      --text-secondary: #5c5751;
      --text-muted: #8a847a;
      --accent: #c45a3b;
      --accent-hover: #a84830;
      --accent-soft: #f8ebe7;
      --border: #ddd8cf;
      --shadow: rgba(45, 42, 38, 0.08);
      --note-bg: #fff9e6;
      --note-border: #f0e4b8;
      --success: #4a7c59;
      --recording: #c45a3b;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      height: 100dvh;
      overflow: hidden;
    }

    body {
      font-family: 'DM Sans', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      background-blend-mode: overlay;
      background-size: 200px;
    }

    .app-container {
      max-width: 1400px;
      margin: 0 auto;
      height: 100%;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 2rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-primary);
      z-index: 100;
      flex-shrink: 0;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .logo-icon {
      width: 36px;
      height: 36px;
      background: var(--accent);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-family: 'Crimson Pro', serif;
      font-size: 1.25rem;
      font-weight: 600;
    }

    .logo-text {
      font-family: 'Crimson Pro', serif;
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .logo-tagline {
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: -0.125rem;
    }

    /* Navigation */
    .nav-tabs {
      display: flex;
      gap: 0.25rem;
      background: var(--bg-secondary);
      padding: 0.25rem;
      border-radius: 10px;
    }

    .nav-tab {
      padding: 0.5rem 1rem;
      border: none;
      background: transparent;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-secondary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .nav-tab:hover {
      color: var(--text-primary);
    }

    .nav-tab.active {
      background: white;
      color: var(--text-primary);
      box-shadow: 0 2px 8px var(--shadow);
    }

    .notes-button {
      margin-left: auto;
      border: 1px solid var(--border);
      background: var(--bg-primary);
    }

    .notes-button:hover:not(:disabled) {
      background: var(--bg-secondary);
      border-color: var(--accent);
    }

    .notes-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .notes-button.active:not(:disabled) {
      background: var(--accent) !important;
      color: white !important;
      border-color: var(--accent) !important;
      box-shadow: 0 2px 8px var(--shadow);
    }

    /* Main Content */
    .main-content {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    .content-area {
      padding: 1rem 2rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

    .sidebar {
      position: fixed;
      right: -360px;
      top: 60px;
      height: calc(100% - 60px);
      height: calc(100dvh - 60px);
      width: 360px;
      padding: 1rem;
      background: var(--bg-secondary);
      overflow-y: auto;
      min-height: 0;
      transition: right 0.3s ease;
      box-shadow: -4px 0 20px var(--shadow);
      z-index: 50;
    }

    .sidebar.open {
      right: 0;
    }

    /* Input Section */
    .input-section {
      margin-bottom: 1rem;
      flex-shrink: 0;
    }

    .input-group {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .url-input {
      flex: 1;
      min-width: 0;
      padding: 0.75rem 1rem;
      border: 2px solid var(--border);
      border-radius: 10px;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.875rem;
      background: white;
      transition: all 0.2s ease;
    }

    .url-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-soft);
    }

    .url-input::placeholder {
      color: var(--text-muted);
    }

    .btn {
      padding: 0.75rem 1.25rem;
      border: none;
      border-radius: 10px;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: var(--border);
    }

    .btn-icon {
      width: 40px;
      height: 40px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
    }

    /* Reader Section */
    .reader-container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 24px var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    .reader-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 1rem;
      flex-shrink: 0;
    }

    .source-info {
      overflow: hidden;
      min-width: 0;
    }

    .source-info h2 {
      font-family: 'Crimson Pro', serif;
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
      line-height: 1.3;
    }

    .source-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 0.75rem;
      overflow: hidden;
      min-width: 0;
    }

    .source-meta .source-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      min-width: 0;
      max-width: 45%;
    }

    .source-meta span:not(.source-name) {
      flex-shrink: 0;
    }

    .source-meta a {
      flex-shrink: 0;
      color: var(--accent);
      text-decoration: none;
    }

    .source-meta a:hover {
      text-decoration: underline;
    }

    .reader-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-shrink: 0;
    }

    .reader-body {
      padding: 1rem 1.5rem;
      flex: 1;
      min-height: 0;
      overflow-y: auto;
    }

    .reader-content {
      font-family: 'Crimson Pro', serif;
      font-size: 1rem;
      line-height: 1.7;
      color: var(--text-primary);
    }

    .reader-content p {
      margin-bottom: 1rem;
    }

    .sentence {
      transition: all 0.2s ease;
      border-radius: 4px;
      padding: 0 2px;
      margin: 0 -2px;
    }

    .sentence.current {
      background: var(--accent-soft);
      color: var(--accent);
    }

    .sentence.has-note {
      background: var(--note-bg);
      border-bottom: 2px solid var(--note-border);
      cursor: pointer;
    }

    .sentence.has-note:hover {
      background: #fff3c4;
    }

    /* Playback Bar */
    .playback-bar {
      padding: 0.5rem 1rem;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-shrink: 0;
      flex-wrap: wrap;
    }

    .playback-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
      min-width: 0;
      flex-wrap: wrap;
    }

    .transport-buttons {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .progress-speed-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex: 1;
      min-width: 0;
    }

    .note-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    @media (max-width: 700px) {
      .playback-controls {
        width: 100%;
        justify-content: center;
      }

      .transport-buttons {
        order: 1;
      }

      .progress-speed-group {
        order: 2;
        flex: 1;
        min-width: 0;
        flex-direction: column;
        gap: 0.25rem;
        align-items: stretch;
      }

      .progress-speed-group .progress-container {
        width: 100%;
      }

      .note-controls {
        order: 3;
        width: 100%;
        justify-content: center;
        padding: 0;
        border: none;
        margin: 0;
      }
    }

    .play-btn {
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .play-btn svg {
      width: 24px;
      height: 24px;
    }

    .play-btn:hover {
      background: var(--accent-hover);
      transform: scale(1.05);
    }

    .skip-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .skip-btn:hover:not(:disabled) {
      background: var(--border);
      transform: scale(1.05);
    }

    .skip-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .play-btn.recording {
      background: var(--recording);
      animation: pulse 1.5s ease infinite;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(196, 90, 59, 0.4); }
      50% { box-shadow: 0 0 0 12px rgba(196, 90, 59, 0); }
    }

    .progress-container {
      flex: 1;
    }

    .progress-bar {
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 0.25rem;
    }

    .progress-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      transition: width 0.1s linear;
    }

    .progress-text {
      font-size: 0.7rem;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.375rem 0.625rem;
      background: white;
      border-radius: 8px;
      border: 1px solid var(--border);
      flex-shrink: 0;
    }

    .speed-control label {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .speed-control select {
      border: none;
      background: transparent;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-primary);
      cursor: pointer;
    }

    /* Voice Note Button */
    .note-btn {
      padding: 0.5rem 0.5rem;
      background: var(--note-bg);
      border: 2px solid var(--note-border);
      border-radius: 10px;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.375rem;
      transition: all 0.2s ease;
      flex: 1;
      min-height: 44px;
      white-space: nowrap;
    }

    .note-btn svg {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .note-btn:hover {
      background: #fff3c4;
      border-color: #e6d9a5;
    }

    .note-btn.recording,
    .note-btn.processing {
      background: #fee2e2;
      border-color: var(--recording);
      color: var(--recording);
      animation: pulse-note 1.5s ease infinite;
    }

    @keyframes pulse-note {
      0%, 100% { box-shadow: 0 0 0 0 rgba(196, 90, 59, 0.3); }
      50% { box-shadow: 0 0 0 8px rgba(196, 90, 59, 0); }
    }

    /* Note controls responsive */
    .note-controls {
      flex-wrap: nowrap;
    }

    /* Car button - square in regular mode */
    .note-btn:nth-child(4):not(.car-mode) {
      flex: 0 0 auto;
      aspect-ratio: 1;
      padding: 0.5rem;
    }

    /* Car Mode */
    .playback-bar.car-mode {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: stretch;
      padding: 1rem;
      gap: 1rem;
      min-height: 0;
    }

    .playback-bar.car-mode .playback-controls {
      width: 100%;
      flex-direction: column;
      gap: 0.75rem;
      flex: 0 0 auto;
      justify-content: flex-start;
    }

    .playback-bar.car-mode .transport-buttons {
      flex: 0 0 auto;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.75rem;
      width: 100%;
    }

    .skip-btn.car-mode,
    .play-btn.car-mode {
      flex: 1;
      max-width: none;
      width: auto;
      height: auto;
      min-width: 60px;
      min-height: 60px;
      font-size: 2rem;
      aspect-ratio: 1;
    }

    .skip-btn.car-mode svg,
    .play-btn.car-mode svg {
      width: 50%;
      height: 50%;
      max-width: 80px;
      max-height: 80px;
    }

    .progress-speed-group.car-mode {
      display: flex;
      width: 100%;
      flex-direction: row;
      gap: 1rem;
      flex-shrink: 0;
      align-items: center;
      margin-top: 0.5rem;
    }

    .progress-speed-group.car-mode .progress-container {
      flex: 1;
    }

    .progress-bar.car-mode {
      height: 8px;
    }

    .speed-control.car-mode {
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    .speed-control.car-mode label {
      font-size: 0.7rem;
      margin: 0;
      line-height: 1;
    }

    .speed-control.car-mode select {
      font-size: 0.8125rem;
      padding: 0;
      border: none;
      background: transparent;
      line-height: 1;
    }

    .playback-bar.car-mode .note-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 0.75rem;
      width: 100%;
      flex: 1;
      min-height: 0;
    }

    /* All note buttons same size */
    .note-btn.car-mode {
      width: 100%;
      height: 100%;
      padding: 1rem;
      font-size: 1.25rem;
      min-height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .note-btn.car-mode svg {
      width: 40px;
      height: 40px;
    }

    .note-btn.car-mode.active {
      background: var(--accent-soft);
      border-color: var(--accent);
      color: var(--accent);
    }

    @media (max-width: 500px) {
      .playback-bar.car-mode {
        padding: 0.75rem;
        gap: 0.75rem;
      }

      .playback-bar.car-mode .playback-controls {
        gap: 0.75rem;
      }

      .playback-bar.car-mode .transport-buttons {
        gap: 0.5rem;
      }

      .skip-btn.car-mode,
      .play-btn.car-mode {
        min-width: 50px;
        min-height: 50px;
        aspect-ratio: 1;
      }

      .note-btn.car-mode {
        min-height: 70px;
        font-size: 1rem;
        padding: 0.75rem;
      }

      .note-btn.car-mode svg {
        width: 28px;
        height: 28px;
      }

      .progress-speed-group.car-mode {
        gap: 0.75rem;
      }

      .speed-control.car-mode select {
        font-size: 0.75rem;
      }
    }

    /* Sidebar Notes */
    .sidebar-title {
      font-family: 'Crimson Pro', serif;
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .notes-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .note-card {
      background: white;
      border-radius: 8px;
      padding: 0.75rem;
      box-shadow: 0 2px 8px var(--shadow);
      border-left: 3px solid var(--accent);
    }

    .note-position {
      font-size: 0.7rem;
      color: var(--accent);
      font-weight: 500;
      margin-bottom: 0.25rem;
      font-family: 'JetBrains Mono', monospace;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .note-position:hover {
      opacity: 0.7;
    }

    .note-text {
      font-size: 0.875rem;
      color: var(--text-primary);
      line-height: 1.4;
      margin-bottom: 0.375rem;
    }

    .note-edit-input {
      width: 100%;
      font-size: 0.875rem;
      color: var(--text-primary);
      line-height: 1.4;
      padding: 0.5rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-primary);
      font-family: inherit;
      resize: vertical;
      margin-bottom: 0.5rem;
    }

    .note-edit-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .note-context {
      font-size: 0.75rem;
      color: var(--text-muted);
      font-style: italic;
      padding-left: 0.5rem;
      border-left: 2px solid var(--border);
    }

    .note-actions {
      display: flex;
      gap: 0.375rem;
      margin-top: 0.5rem;
    }

    .note-action-btn {
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--border);
      background: var(--bg-primary);
      border-radius: 6px;
      font-size: 0.7rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .note-action-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .note-action-btn.delete:hover {
      border-color: #dc2626;
      color: #dc2626;
    }

    /* Library View */
    .library-grid {
      display: grid;
      gap: 1rem;
    }

    .library-date-group {
      margin-bottom: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .date-header {
      font-family: 'Crimson Pro', serif;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-secondary);
      padding-bottom: 0.5rem;
      border-bottom: 2px solid var(--border);
      margin-bottom: 0.75rem;
    }

    .library-item {
      background: white;
      border-radius: 10px;
      padding: 1rem;
      box-shadow: 0 2px 12px var(--shadow);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .library-item-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.75rem;
    }

    .library-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px var(--shadow);
    }

    .library-item-title {
      font-family: 'Crimson Pro', serif;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .library-item-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .library-item-meta a {
      color: var(--accent);
      display: flex;
      align-items: center;
    }

    .library-item-meta a:hover {
      color: var(--accent-hover);
    }

    .library-item-type {
      padding: 0.1875rem 0.5rem;
      background: var(--bg-secondary);
      border-radius: 4px;
      font-size: 0.625rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
    }

    .library-item-type.article { background: #dbeafe; color: #1e40af; }
    .library-item-type.pdf { background: #fee2e2; color: #991b1b; }
    .library-item-type.youtube { background: #fce7f3; color: #9d174d; }
    .library-item-type.podcast { background: #d1fae5; color: #065f46; }

    .note-count {
      padding: 0.25rem 0.5rem;
      background: var(--note-bg);
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .read-status {
      width: 22px;
      height: 22px;
      border: 2px solid var(--border);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      color: transparent;
      flex-shrink: 0;
      align-self: center;
    }

    .read-status.checked {
      background: var(--success);
      border-color: var(--success);
      color: white;
    }

    .read-status.clickable {
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .read-status.clickable:hover {
      border-color: var(--success);
    }

    .read-status.clickable.checked:hover {
      background: #3d6649;
      border-color: #3d6649;
    }

    /* Media Player Section */
    .media-container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 24px var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    .youtube-container {
      flex: 1;
      min-height: 0;
      background: #000;
      position: relative;
    }

    .youtube-container iframe {
      width: 100%;
      height: 100%;
    }

    .audio-visualizer {
      height: 80px;
      background: linear-gradient(180deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .audio-bar {
      width: 4px;
      background: var(--accent);
      border-radius: 2px;
      transition: height 0.1s ease;
    }

    /* Empty States */
    .empty-state {
      text-align: center;
      padding: 2rem 1rem;
      color: var(--text-muted);
    }

    .empty-state-icon {
      width: 60px;
      height: 60px;
      margin: 0 auto 1rem;
      background: var(--bg-secondary);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }

    .empty-state h3 {
      font-family: 'Crimson Pro', serif;
      font-size: 1.25rem;
      color: var(--text-secondary);
      margin-bottom: 0.375rem;
    }

    .empty-state p {
      font-size: 0.875rem;
      max-width: 400px;
      margin: 0 auto;
    }

    /* Export Section */
    .export-section {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }

    .export-btn {
      width: 100%;
      padding: 0.625rem;
      background: var(--bg-tertiary);
      border: 2px dashed var(--border);
      border-radius: 8px;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.8rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.375rem;
    }

    .export-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--accent-soft);
    }

    /* Tabs for Media */
    .media-tabs {
      display: flex;
      gap: 0;
      background: var(--bg-tertiary);
      border-radius: 8px;
      padding: 0.25rem;
      margin-bottom: 0.75rem;
      flex-shrink: 0;
    }

    .media-tab {
      flex: 1;
      padding: 0.5rem 1rem;
      border: none;
      background: transparent;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s ease;
    }

    .media-tab.active {
      background: white;
      color: var(--text-primary);
      box-shadow: 0 1px 4px var(--shadow);
    }

    /* Subscription List */
    .subscription-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
      flex-shrink: 0;
      max-height: 150px;
      overflow-y: auto;
    }

    .subscription-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .subscription-item:hover {
      background: var(--bg-tertiary);
    }

    .subscription-item.active {
      background: var(--accent-soft);
      border: 1px solid var(--accent);
    }

    .subscription-thumb {
      width: 36px;
      height: 36px;
      border-radius: 6px;
      background: var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      flex-shrink: 0;
    }

    .subscription-info {
      flex: 1;
      min-width: 0;
    }

    .subscription-title {
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .subscription-channel {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    /* Toast Notification */
    .toast {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--text-primary);
      color: white;
      padding: 0.875rem 1.5rem;
      border-radius: 10px;
      font-size: 0.9375rem;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .toast {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .undo-btn {
      background: white;
      color: var(--text-primary);
      border: none;
      padding: 0.375rem 0.75rem;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .undo-btn:hover {
      background: var(--bg-secondary);
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
    }

    .modal-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: white;
      border-radius: 16px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow: auto;
      transform: scale(0.95);
      transition: all 0.2s ease;
    }

    .modal-overlay.show .modal {
      transform: scale(1);
    }

    .modal-header {
      padding: 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal-title {
      font-family: 'Crimson Pro', serif;
      font-size: 1.375rem;
      font-weight: 600;
    }

    .modal-close {
      width: 36px;
      height: 36px;
      border: none;
      background: var(--bg-secondary);
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      color: var(--text-secondary);
    }

    .modal-close:hover {
      background: var(--bg-tertiary);
    }

    .modal-body {
      padding: 1.5rem;
    }

    .modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
    }

    /* Text Note Input */
    .text-note-container {
      padding: 0.75rem 1.5rem;
      background: var(--note-bg);
      border-top: 1px solid var(--note-border);
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .text-note-input {
      flex: 1;
    }

    .text-note-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .search-container {
      padding: 0.75rem 1.5rem;
      background: var(--note-bg);
      border-top: 1px solid var(--note-border);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .search-container > .url-input {
      flex: 1;
    }

    .search-results {
      max-height: 300px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .search-result-item {
      padding: 0.75rem;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      border: 1px solid var(--border);
      transition: all 0.2s ease;
    }

    .search-result-item:hover {
      background: var(--bg-secondary);
      border-color: var(--accent);
    }

    /* Library Actions */
    .library-actions {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      flex-shrink: 0;
      flex-wrap: wrap;
    }

    .library-actions .btn {
      padding: 0.5rem 0.75rem;
    }

    /* Responsive */
    @media (max-width: 640px) {
      .header {
        flex-direction: column;
        gap: 0.5rem;
        padding: 0.75rem 1rem;
      }

      .library-actions {
        justify-content: center;
      }

      .logo-text {
        font-size: 1.5rem;
      }

      .logo-icon {
        width: 32px;
        height: 32px;
        font-size: 1.25rem;
      }

      .content-area {
        padding: 0.75rem 1rem;
      }

      .input-group {
        gap: 0.5rem;
      }

      .reader-header {
        flex-direction: column;
        padding: 0.75rem 1rem;
        position: relative;
      }

      .reader-header .read-status {
        position: absolute;
        top: 0.75rem;
        right: 1rem;
        margin-top: 0 !important;
      }

      .source-info h2 {
        font-size: 1.1rem;
        padding-right: 2rem;
      }

      .reader-body {
        padding: 0.75rem 1rem;
      }

      .reader-content {
        font-size: 0.9rem;
        line-height: 1.6;
      }

      .speed-control {
        padding: 0.375rem 0.5rem;
      }

      .speed-control label {
        font-size: 0.7rem;
      }

      .speed-control select {
        font-size: 0.8rem;
      }

      .nav-tab {
        padding: 0.5rem 0.75rem;
        font-size: 0.8rem;
      }

      .text-note-container {
        flex-direction: column;
        align-items: stretch;
        padding: 0.75rem 1rem;
      }

      .text-note-input {
        width: 100%;
        margin-bottom: 0.5rem;
      }

      .text-note-buttons {
        width: 100%;
        justify-content: stretch;
      }

      .text-note-buttons .btn {
        flex: 1;
      }

      .search-container {
        padding: 0.75rem 1rem;
      }
    }

    @media (max-height: 700px) {
      .header {
        padding: 0.5rem 1rem;
      }

      .logo-tagline {
        display: none;
      }

      .content-area {
        padding: 0.5rem 1rem;
      }

      .reader-header {
        padding: 0.5rem 1rem;
      }

      .reader-body {
        padding: 0.5rem 1rem;
      }

      .playback-bar {
        padding: 0.5rem 1rem;
      }

      .empty-state {
        padding: 1rem;
      }

      .empty-state-icon {
        width: 48px;
        height: 48px;
        font-size: 1.25rem;
      }
    }

    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback, useImperativeHandle } = React;

    // Icons
    const Icons = {
      Play: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>,
      Pause: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>,
      Mic: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>,
      MicOff: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"/><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>,
      Book: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>,
      Library: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><line x1="8" y1="6" x2="16" y2="6"/><line x1="8" y1="10" x2="16" y2="10"/><line x1="8" y1="14" x2="12" y2="14"/></svg>,
      Headphones: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 18v-6a9 9 0 0 1 18 0v6"/><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"/></svg>,
      Link: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>,
      Copy: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>,
      Trash: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>,
      X: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>,
      Menu: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>,
      StickyNote: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M15.5 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3Z"/><path d="M15 3v6h6"/></svg>,
      Download: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>,
      YouTube: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M23.5 6.2c-.3-1-1-1.8-2-2.1C19.6 3.5 12 3.5 12 3.5s-7.6 0-9.5.5c-1 .3-1.7 1.1-2 2.1C0 8.1 0 12 0 12s0 3.9.5 5.8c.3 1 1 1.8 2 2.1 1.9.5 9.5.5 9.5.5s7.6 0 9.5-.5c1-.3 1.7-1.1 2-2.1.5-1.9.5-5.8.5-5.8s0-3.9-.5-5.8zM9.5 15.5v-7l6.4 3.5-6.4 3.5z"/></svg>,
      Podcast: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M13 17a1 1 0 1 0-2 0l.5 4.5a.5.5 0 0 0 1 0z" fill="currentColor"/><path d="M16.85 18.58a9 9 0 1 0-9.7 0"/><path d="M8 14a5 5 0 1 1 8 0"/><circle cx="12" cy="11" r="1" fill="currentColor"/></svg>,
      Edit: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>,
      Plus: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
      FileText: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>,
      SkipBack: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19 20L9 12l10-8v16zM5 19V5h2v14H5z"/></svg>,
      SkipForward: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M5 4l10 8-10 8V4zm14 1v14h-2V5h2z"/></svg>,
      Rewind: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M11 19l-9-7 9-7v14z"/><path d="M22 19l-9-7 9-7v14z"/></svg>,
      FastForward: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M13 19l9-7-9-7v14z"/><path d="M2 19l9-7-9-7v14z"/></svg>,
      Search: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>,
      Car: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 17h2c.6 0 1-.4 1-1v-3.15a1 1 0 0 0-.84-.99L16 11l-2.7-3.6a1 1 0 0 0-.8-.4H5.24a2 2 0 0 0-1.8 1.1l-.8 1.63A6 6 0 0 0 2 12.42V16h2"/><circle cx="6.5" cy="16.5" r="2.5"/><circle cx="16.5" cy="16.5" r="2.5"/></svg>,
      BookOpen: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>,
      Library: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="m16 6 4 14"/><path d="M12 6v14"/><path d="M8 8v12"/><path d="M4 4v16"/></svg>,
      Keyboard: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="20" height="16" x="2" y="4" rx="2"/><path d="M6 8h.01"/><path d="M10 8h.01"/><path d="M14 8h.01"/><path d="M18 8h.01"/><path d="M8 12h.01"/><path d="M12 12h.01"/><path d="M16 12h.01"/><path d="M7 16h10"/></svg>,
      Pencil: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>,
      Eraser: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg>,
      FolderDown: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"/><path d="M12 10v6"/><path d="m15 13-3 3-3-3"/></svg>,
      FolderUp: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"/><path d="M12 10v6"/><path d="m9 13 3-3 3 3"/></svg>,
      Check: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"/></svg>,
      Image: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>,
    };

    // Utility functions
    const generateId = () => Math.random().toString(36).substr(2, 9);
    const safeHostname = (url) => {
      try {
        return new URL(url).hostname;
      } catch {
        try {
          return new URL('https://' + url).hostname;
        } catch {
          return url;
        }
      }
    };
    const formatDate = (date) => new Date(date).toLocaleDateString('en-US', { 
      weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
    });
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    // Toast Component
    function Toast({ message, show, onUndo, showUndo }) {
      return (
        <div className={`toast ${show ? 'show' : ''}`}>
          <span>{message}</span>
          {showUndo && onUndo && (
            <button className="undo-btn" onClick={onUndo}>
              Undo
            </button>
          )}
        </div>
      );
    }

    // Audio feedback utility
    const playSound = (type) => {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.type = 'sine';
        gainNode.gain.value = 0.3; // Volume

        const now = audioContext.currentTime;

        if (type === 'start') {
          // High beep for start recording
          oscillator.frequency.value = 800;
          gainNode.gain.setValueAtTime(0.3, now);
          gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
          oscillator.start(now);
          oscillator.stop(now + 0.1);
        } else if (type === 'stop') {
          // Low beep for stop recording
          oscillator.frequency.value = 400;
          gainNode.gain.setValueAtTime(0.3, now);
          gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
          oscillator.start(now);
          oscillator.stop(now + 0.1);
        } else if (type === 'success') {
          // Two-tone chime for success
          oscillator.frequency.setValueAtTime(523, now);
          oscillator.frequency.setValueAtTime(659, now + 0.1);
          gainNode.gain.setValueAtTime(0.3, now);
          gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
          oscillator.start(now);
          oscillator.stop(now + 0.3);
        } else if (type === 'error') {
          // Low buzz for error
          oscillator.type = 'square';
          oscillator.frequency.value = 200;
          gainNode.gain.setValueAtTime(0.2, now);
          gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
          oscillator.start(now);
          oscillator.stop(now + 0.2);
        }
      } catch (err) {
        console.log('Audio feedback unavailable:', err);
      }
    };

    // Media Session API utility for Android Auto / lock screen controls
    const MediaSessionManager = {
      // Silent audio element for TTS media session activation
      silentAudio: null,

      // Initialize silent audio for TTS (creates an inaudible audio loop to activate media session)
      initSilentAudio: () => {
        if (MediaSessionManager.silentAudio) return MediaSessionManager.silentAudio;

        // Create a short silent audio using a data URI (tiny silent WAV)
        const silentWav = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
        const audio = new Audio(silentWav);
        audio.loop = true;
        audio.volume = 0.01; // Near-silent but not zero (some browsers ignore zero)
        MediaSessionManager.silentAudio = audio;
        return audio;
      },

      // Set metadata for the current media
      setMetadata: ({ title, artist, album, artwork }) => {
        if (!('mediaSession' in navigator)) return;

        try {
          const metadata = {
            title: title || 'Unknown',
            artist: artist || 'HarkenJot',
            album: album || ''
          };

          // Add artwork if provided
          if (artwork) {
            metadata.artwork = [
              { src: artwork, sizes: '96x96', type: 'image/png' },
              { src: artwork, sizes: '128x128', type: 'image/png' },
              { src: artwork, sizes: '192x192', type: 'image/png' },
              { src: artwork, sizes: '256x256', type: 'image/png' },
              { src: artwork, sizes: '384x384', type: 'image/png' },
              { src: artwork, sizes: '512x512', type: 'image/png' }
            ];
          }

          navigator.mediaSession.metadata = new MediaMetadata(metadata);
        } catch (err) {
          console.log('Media Session metadata error:', err);
        }
      },

      // Set playback state
      setPlaybackState: (state) => {
        if (!('mediaSession' in navigator)) return;
        try {
          navigator.mediaSession.playbackState = state; // 'playing', 'paused', 'none'
        } catch (err) {
          console.log('Media Session playback state error:', err);
        }
      },

      // Set position state for seekable media
      setPositionState: ({ duration, position, playbackRate }) => {
        if (!('mediaSession' in navigator)) return;
        try {
          if (duration && isFinite(duration) && duration > 0) {
            navigator.mediaSession.setPositionState({
              duration: duration,
              position: Math.min(position || 0, duration),
              playbackRate: playbackRate || 1
            });
          }
        } catch (err) {
          console.log('Media Session position error:', err);
        }
      },

      // Set action handlers
      setActionHandlers: ({ onPlay, onPause, onSeekBackward, onSeekForward, onPreviousTrack, onNextTrack }) => {
        if (!('mediaSession' in navigator)) return;

        const handlers = [
          ['play', onPlay],
          ['pause', onPause],
          ['seekbackward', onSeekBackward],
          ['seekforward', onSeekForward],
          ['previoustrack', onPreviousTrack],
          ['nexttrack', onNextTrack]
        ];

        handlers.forEach(([action, handler]) => {
          try {
            navigator.mediaSession.setActionHandler(action, handler || null);
          } catch (err) {
            console.log(`Media Session handler '${action}' not supported:`, err);
          }
        });
      },

      // Clear all handlers
      clearHandlers: () => {
        if (!('mediaSession' in navigator)) return;

        const actions = ['play', 'pause', 'seekbackward', 'seekforward', 'previoustrack', 'nexttrack'];
        actions.forEach(action => {
          try {
            navigator.mediaSession.setActionHandler(action, null);
          } catch (err) {
            // Ignore errors when clearing
          }
        });
      },

      // Stop silent audio (for TTS cleanup)
      stopSilentAudio: () => {
        if (MediaSessionManager.silentAudio) {
          MediaSessionManager.silentAudio.pause();
          MediaSessionManager.silentAudio.currentTime = 0;
        }
      }
    };

    // Migrate localStorage from old 'marginalia_' keys to new 'harkenjot_' keys
    (function migrateLocalStorage() {
      const migrations = [
        ['marginalia_sources', 'harkenjot_sources'],
        ['marginalia_notes', 'harkenjot_notes'],
        ['harkenjot_positions', 'harkenjot_positions'],
        ['harkenjot_subscriptions', 'harkenjot_subscriptions'],
        ['harkenjot_media_positions', 'harkenjot_media_positions']
      ];
      migrations.forEach(([oldKey, newKey]) => {
        const oldData = localStorage.getItem(oldKey);
        if (oldData && !localStorage.getItem(newKey)) {
          localStorage.setItem(newKey, oldData);
          localStorage.removeItem(oldKey);
        }
      });
    })();

    // Main App
    function App() {
      const [activeTab, setActiveTab] = useState('reader');
      const [sources, setSources] = useState(() => {
        const saved = localStorage.getItem('harkenjot_sources');
        return saved ? JSON.parse(saved) : [];
      });
      const [currentSource, setCurrentSource] = useState(null);
      const [notes, setNotes] = useState(() => {
        const saved = localStorage.getItem('harkenjot_notes');
        return saved ? JSON.parse(saved) : [];
      });
      const [toast, setToast] = useState({ show: false, message: '' });
      const [sidebarOpen, setSidebarOpen] = useState(false);
      const [undoData, setUndoData] = useState(null);
      const [carMode, setCarMode] = useState(false);
      const [isMobileDevice, setIsMobileDevice] = useState(false);

      const readerRef = useRef(null);
      const mediaRef = useRef(null);
      const undoTimeoutRef = useRef(null);

      // Detect if user is on a mobile device
      useEffect(() => {
        const checkMobile = () => {
          const userAgent = navigator.userAgent || navigator.vendor || window.opera;
          // Check for mobile devices (iOS, Android, Windows Phone)
          const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
          setIsMobileDevice(isMobile);
        };
        checkMobile();
      }, []);

      // Save to localStorage
      useEffect(() => {
        localStorage.setItem('harkenjot_sources', JSON.stringify(sources));
      }, [sources]);

      useEffect(() => {
        localStorage.setItem('harkenjot_notes', JSON.stringify(notes));
      }, [notes]);

      // Close sidebar when changing tabs
      useEffect(() => {
        setSidebarOpen(false);
      }, [activeTab]);

      // Ensure voices are loaded
      useEffect(() => {
        // Load voices immediately if available
        const voices = window.speechSynthesis.getVoices();

        // Some browsers load voices asynchronously
        if (!voices.length) {
          window.speechSynthesis.addEventListener('voiceschanged', () => {
            window.speechSynthesis.getVoices();
          }, { once: true });
        }
      }, []);

      const showToast = (message) => {
        setToast({ show: true, message });
        setTimeout(() => setToast({ show: false, message: '' }), 3000);
      };

      const addSource = (source) => {
        const newSource = { ...source, id: generateId(), createdAt: new Date().toISOString() };
        setSources(prev => [newSource, ...prev]);
        setCurrentSource(newSource);
        showToast('Source added to library');
        return newSource;
      };

      const updateSource = (sourceId, updates) => {
        setSources(prev => prev.map(s => s.id === sourceId ? { ...s, ...updates } : s));
        setCurrentSource(prev => prev?.id === sourceId ? { ...prev, ...updates } : prev);
      };

      const addNote = (note) => {
        const newNote = { ...note, id: generateId(), createdAt: new Date().toISOString() };
        setNotes(prev => {
          // Insert note in sequential order among notes for the same source
          const otherNotes = prev.filter(n => n.sourceId !== newNote.sourceId);
          const sourceNotes = prev.filter(n => n.sourceId === newNote.sourceId);

          // Find insertion index based on position (articles/PDFs) or timestamp (media)
          let insertIdx = sourceNotes.length;
          for (let i = 0; i < sourceNotes.length; i++) {
            const existing = sourceNotes[i];
            if (newNote.timestamp !== undefined && existing.timestamp !== undefined) {
              if (newNote.timestamp < existing.timestamp) { insertIdx = i; break; }
            } else if (newNote.position !== undefined && existing.position !== undefined) {
              if (newNote.position < existing.position) { insertIdx = i; break; }
            }
          }

          sourceNotes.splice(insertIdx, 0, newNote);
          return [...sourceNotes, ...otherNotes];
        });
        showToast('Note saved');
      };

      const deleteNote = (noteId) => {
        const noteToDelete = notes.find(n => n.id === noteId);
        if (!noteToDelete) return;

        setNotes(prev => prev.filter(n => n.id !== noteId));

        // Set up undo
        clearTimeout(undoTimeoutRef.current);
        setUndoData({ type: 'note', data: noteToDelete });
        setToast({ show: true, message: 'Note deleted', showUndo: true });

        // Auto-clear undo after 5 seconds
        undoTimeoutRef.current = setTimeout(() => {
          setUndoData(null);
          setToast({ show: false, message: '', showUndo: false });
        }, 5000);
      };

      const updateNote = (noteId, updatedText) => {
        setNotes(prev => prev.map(n =>
          n.id === noteId ? { ...n, text: updatedText } : n
        ));
        showToast('Note updated');
      };

      const handleUndo = () => {
        if (!undoData) return;

        clearTimeout(undoTimeoutRef.current);

        if (undoData.type === 'note') {
          setNotes(prev => [undoData.data, ...prev]);
          showToast('Note restored');
        } else if (undoData.type === 'source') {
          setSources(prev => [undoData.data.source, ...prev]);
          setNotes(prev => [...undoData.data.notes, ...prev]);
          showToast('Item restored');
        }

        setUndoData(null);
      };

      const navigateToNote = (note) => {
        setSidebarOpen(false);

        if (note.timestamp !== undefined) {
          // Video note - seek to timestamp
          setActiveTab('media');
          setTimeout(() => {
            if (mediaRef.current?.seekTo) {
              mediaRef.current.seekTo(note.timestamp);
            }
          }, 100);
        } else if (note.position !== undefined) {
          // Article/PDF note - go to sentence
          setActiveTab('reader');
          setTimeout(() => {
            if (readerRef.current?.navigateToSentence) {
              readerRef.current.navigateToSentence(note.position);
            }
          }, 100);
        }
      };

      const deleteSource = (sourceId) => {
        const sourceToDelete = sources.find(s => s.id === sourceId);
        if (!sourceToDelete) return;

        const relatedNotes = notes.filter(n => n.sourceId === sourceId);

        setSources(prev => prev.filter(s => s.id !== sourceId));
        setNotes(prev => prev.filter(n => n.sourceId !== sourceId));
        if (currentSource?.id === sourceId) {
          setCurrentSource(null);
        }

        // Set up undo
        clearTimeout(undoTimeoutRef.current);
        setUndoData({ type: 'source', data: { source: sourceToDelete, notes: relatedNotes } });
        setToast({ show: true, message: 'Item deleted from library', showUndo: true });

        // Auto-clear undo after 5 seconds
        undoTimeoutRef.current = setTimeout(() => {
          setUndoData(null);
          setToast({ show: false, message: '', showUndo: false });
        }, 5000);
      };

      const currentNotes = notes.filter(n => n.sourceId === currentSource?.id).sort((a, b) => {
        // Sort notes sequentially by source position (earliest in source first)
        if (a.timestamp !== undefined && b.timestamp !== undefined) {
          return a.timestamp - b.timestamp;
        }
        if (a.position !== undefined && b.position !== undefined) {
          return a.position - b.position;
        }
        // Fallback: maintain creation order
        return new Date(a.createdAt) - new Date(b.createdAt);
      });

      // Determine if notes button should be enabled based on current tab and source type
      const isNotesAvailable = (() => {
        if (activeTab === 'library') return false;
        if (!currentSource) return false;
        if (activeTab === 'reader') {
          return currentSource.type === 'article' || currentSource.type === 'pdf';
        }
        if (activeTab === 'media') {
          return currentSource.type === 'youtube' || currentSource.type === 'podcast';
        }
        return false;
      })();

      return (
        <div className="app-container">
          <header className="header">
            <div className="logo">
              <div className="logo-icon">H</div>
              <div>
                <div className="logo-text">HarkenJot <span style={{ fontSize: '0.6rem', color: 'var(--text-muted)', fontWeight: 400 }}>v1.8.5</span></div>
                <div className="logo-tagline">Take Notes While You Listen</div>
              </div>
            </div>
            <nav className="nav-tabs">
              <button
                className={`nav-tab ${activeTab === 'reader' ? 'active' : ''}`}
                onClick={() => { setActiveTab('reader'); setCarMode(false); }}
              >
                <Icons.BookOpen /> Reader
              </button>
              <button
                className={`nav-tab ${activeTab === 'media' ? 'active' : ''}`}
                onClick={() => { setActiveTab('media'); setCarMode(false); }}
              >
                <Icons.Podcast /> Player
              </button>
              <button
                className={`nav-tab ${activeTab === 'library' ? 'active' : ''}`}
                onClick={() => { setActiveTab('library'); setCarMode(false); }}
              >
                <Icons.Library /> Library
              </button>
              <button
                className={`nav-tab notes-button ${sidebarOpen && isNotesAvailable ? 'active' : ''} ${!isNotesAvailable ? 'disabled' : ''}`}
                onClick={() => { if (isNotesAvailable) { setSidebarOpen(!sidebarOpen); setCarMode(false); }}}
                disabled={!isNotesAvailable}
                style={{ position: 'relative' }}
                title={!isNotesAvailable ? (activeTab === 'library' ? 'Notes not available in library view' : 'Load a source to view notes') : 'Toggle notes'}
              >
                <Icons.Pencil /> Notes
                {isNotesAvailable && currentNotes.length > 0 && (
                  <span style={{
                    position: 'absolute',
                    top: '2px',
                    right: '2px',
                    background: 'var(--accent)',
                    color: 'white',
                    fontSize: '0.6rem',
                    minWidth: '14px',
                    height: '14px',
                    borderRadius: '7px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}>{currentNotes.length}</span>
                )}
              </button>
            </nav>
          </header>

          <main className="main-content">
            <div className="content-area">
              {activeTab === 'reader' && (
                <ReaderView
                  ref={readerRef}
                  currentSource={currentSource}
                  setCurrentSource={setCurrentSource}
                  addSource={addSource}
                  updateSource={updateSource}
                  addNote={addNote}
                  notes={currentNotes}
                  showToast={showToast}
                  carMode={carMode}
                  setCarMode={setCarMode}
                  isMobileDevice={isMobileDevice}
                />
              )}
              {activeTab === 'media' && (
                <MediaView
                  ref={mediaRef}
                  currentSource={currentSource}
                  setCurrentSource={setCurrentSource}
                  addSource={addSource}
                  updateSource={updateSource}
                  addNote={addNote}
                  notes={currentNotes}
                  showToast={showToast}
                  setActiveTab={setActiveTab}
                  carMode={carMode}
                  setCarMode={setCarMode}
                  isMobileDevice={isMobileDevice}
                />
              )}
              {activeTab === 'library' && (
                <LibraryView
                  sources={sources}
                  notes={notes}
                  setCurrentSource={(source) => {
                    setCurrentSource(source);
                    setActiveTab(source.type === 'youtube' || source.type === 'podcast' ? 'media' : 'reader');
                  }}
                  openSourceWithNotes={(source) => {
                    setCurrentSource(source);
                    setActiveTab(source.type === 'youtube' || source.type === 'podcast' ? 'media' : 'reader');
                    // Delay sidebar open to run after the useEffect that closes sidebar on tab change
                    setTimeout(() => setSidebarOpen(true), 0);
                  }}
                  deleteNote={deleteNote}
                  deleteSource={deleteSource}
                  updateSource={updateSource}
                  setSources={setSources}
                  setNotes={setNotes}
                  showToast={showToast}
                />
              )}
            </div>

            <aside className={`sidebar ${sidebarOpen ? 'open' : ''}`}>
              <NoteSidebar
                notes={currentNotes}
                currentSource={currentSource}
                deleteNote={deleteNote}
                updateNote={updateNote}
                navigateToNote={navigateToNote}
                showToast={showToast}
                onClose={() => setSidebarOpen(false)}
              />
            </aside>
          </main>

          <Toast {...toast} onUndo={handleUndo} />
        </div>
      );
    }

    // Editable Title Component
    const EditableTitle = ({ title, onSave, style = {} }) => {
      const [isEditing, setIsEditing] = useState(false);
      const [editValue, setEditValue] = useState(title);
      const inputRef = useRef(null);

      useEffect(() => {
        setEditValue(title);
      }, [title]);

      useEffect(() => {
        if (isEditing && inputRef.current) {
          inputRef.current.focus();
          inputRef.current.select();
        }
      }, [isEditing]);

      const handleSave = () => {
        const trimmedValue = editValue.trim();
        if (trimmedValue && trimmedValue !== title) {
          onSave(trimmedValue);
        } else {
          setEditValue(title);
        }
        setIsEditing(false);
      };

      const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
          handleSave();
        } else if (e.key === 'Escape') {
          setEditValue(title);
          setIsEditing(false);
        }
      };

      if (isEditing) {
        return (
          <input
            ref={inputRef}
            type="text"
            value={editValue}
            onChange={(e) => setEditValue(e.target.value)}
            onBlur={handleSave}
            onKeyDown={handleKeyDown}
            className="editable-title-input"
            style={{
              flex: 1,
              fontSize: 'inherit',
              fontWeight: 'inherit',
              fontFamily: 'inherit',
              padding: '0.25rem 0.5rem',
              border: '2px solid var(--accent)',
              borderRadius: '6px',
              background: 'white',
              outline: 'none',
              ...style
            }}
          />
        );
      }

      return (
        <h2
          onClick={() => setIsEditing(true)}
          title="Click to edit title"
          style={{
            flex: 1,
            cursor: 'pointer',
            ...style
          }}
        >
          {title}<span style={{ opacity: 0.4, display: 'inline-flex', verticalAlign: 'middle', marginLeft: '0.4rem', flexShrink: 0 }}><Icons.Eraser /></span>
        </h2>
      );
    };

    // Reader View Component
    const ReaderView = React.forwardRef(({ currentSource, setCurrentSource, addSource, updateSource, addNote, notes, showToast, carMode, setCarMode, isMobileDevice }, ref) => {
      const [url, setUrl] = useState('');
      const [loading, setLoading] = useState(false);
      const [content, setContent] = useState(null);
      const [isPlaying, setIsPlaying] = useState(false);
      const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0);
      const [isRecording, setIsRecording] = useState(false);
      const [speed, setSpeed] = useState(1);
      const [manualContent, setManualContent] = useState('');
      const [showManualInput, setShowManualInput] = useState(false);
      const [showTextNote, setShowTextNote] = useState(false);
      const [textNote, setTextNote] = useState('');
      const [speechReady, setSpeechReady] = useState(false);
      const [useWhisperFallback, setUseWhisperFallback] = useState(false);
      const [whisperLoading, setWhisperLoading] = useState(false);
      const [whisperProgress, setWhisperProgress] = useState(0);
      const [isTranscribing, setIsTranscribing] = useState(false);
      const [autoScroll, setAutoScroll] = useState(true);
      const [showSearch, setShowSearch] = useState(false);
      const [searchQuery, setSearchQuery] = useState('');
      const [searchResults, setSearchResults] = useState([]);

      const utteranceRef = useRef(null);
      const mediaRecorderRef = useRef(null);
      const audioChunksRef = useRef([]);
      const streamRef = useRef(null);
      const sentencesRef = useRef([]);
      const wasPlayingRef = useRef(false);
      const interruptedSentenceRef = useRef(0);
      const speakFromIndexRef = useRef(null);
      const lastBackPressRef = useRef(0);
      const wasCancelledRef = useRef(false);
      const wakeLockRef = useRef(null);
      const sentenceRefs = useRef({});
      const readerContainerRef = useRef(null);
      const isManualScrollingRef = useRef(false);
      const isStartingRecordingRef = useRef(false);

      // Expose navigation method to parent
      useImperativeHandle(ref, () => ({
        navigateToSentence: (index) => {
          setCurrentSentenceIndex(index);
          setAutoScroll(true);
          // Scroll to the sentence after a brief delay to ensure render
          setTimeout(() => {
            const sentenceElement = sentenceRefs.current[index];
            if (sentenceElement) {
              sentenceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 100);
        }
      }));

      // Auto-scroll to current sentence when playing
      useEffect(() => {
        if (autoScroll && content) {
          const sentenceElement = sentenceRefs.current[currentSentenceIndex];
          if (sentenceElement) {
            isManualScrollingRef.current = false;
            sentenceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }
      }, [currentSentenceIndex, autoScroll, content]);

      // Detect manual scrolling to disable auto-scroll
      useEffect(() => {
        const container = readerContainerRef.current;
        if (!container) return;

        let scrollTimeout;
        const handleScroll = () => {
          // Only disable auto-scroll if this is a user-initiated scroll
          if (!isManualScrollingRef.current && autoScroll) {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
              setAutoScroll(false);
            }, 150);
          }
          isManualScrollingRef.current = false;
        };

        container.addEventListener('scroll', handleScroll, { passive: true });
        return () => {
          container.removeEventListener('scroll', handleScroll);
          clearTimeout(scrollTimeout);
        };
      }, [autoScroll]);

      // Skip to next sentence (stops current and plays next)
      const skipForward = () => {
        if (currentSentenceIndex < sentencesRef.current.length - 1) {
          setAutoScroll(true);
          wasCancelledRef.current = true;
          window.speechSynthesis.cancel();
          const nextIndex = currentSentenceIndex + 1;
          setCurrentSentenceIndex(nextIndex);
          if (isPlaying && speakFromIndexRef.current) {
            setTimeout(() => speakFromIndexRef.current(nextIndex), 50);
          }
        }
      };

      // Skip back - restart current sentence, or go to previous if pressed quickly
      const skipBack = () => {
        setAutoScroll(true);
        const now = Date.now();
        const timeSinceLastPress = now - lastBackPressRef.current;
        lastBackPressRef.current = now;

        wasCancelledRef.current = true;
        window.speechSynthesis.cancel();

        // If pressed within 1.5 seconds, go to previous sentence
        if (timeSinceLastPress < 1500 && currentSentenceIndex > 0) {
          const prevIndex = currentSentenceIndex - 1;
          setCurrentSentenceIndex(prevIndex);
          if (isPlaying && speakFromIndexRef.current) {
            setTimeout(() => speakFromIndexRef.current(prevIndex), 50);
          }
        } else {
          // Restart current sentence
          if (isPlaying && speakFromIndexRef.current) {
            setTimeout(() => speakFromIndexRef.current(currentSentenceIndex), 50);
          }
        }
      };

      // Search functionality
      const handleSearch = (query) => {
        setSearchQuery(query);
        if (!query.trim() || !content) {
          setSearchResults([]);
          return;
        }

        const results = [];
        const lowerQuery = query.toLowerCase();
        sentencesRef.current.forEach((sentence, index) => {
          if (sentence.toLowerCase().includes(lowerQuery)) {
            results.push({ index, sentence });
          }
        });
        setSearchResults(results);
      };

      const navigateToSearchResult = (index) => {
        setCurrentSentenceIndex(index);
        setAutoScroll(true);
        setShowSearch(false);
        setTimeout(() => {
          const sentenceElement = sentenceRefs.current[index];
          if (sentenceElement) {
            sentenceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }, 100);
      };

      // Check Web Speech API availability on mount
      useEffect(() => {
        if (window.WebSpeechAPI?.isSupported) {
          setSpeechReady(true);
          console.log('ReaderView: Web Speech API ready');
          // Check if we previously had network errors and Whisper is loaded
          if (window.WebSpeechAPI.hasNetworkError && window.WhisperASR?.isReady) {
            setUseWhisperFallback(true);
            console.log('ReaderView: Using Whisper fallback due to previous network errors');
          }
        } else if (window.WhisperASR) {
          // Web Speech not supported, Whisper available as fallback
          console.log('ReaderView: Web Speech API not supported, Whisper fallback available');
          setSpeechReady(true); // Enable button, will use Whisper
          setUseWhisperFallback(true);
        } else {
          console.log('ReaderView: No speech recognition available');
          showToast('Speech recognition not supported in this browser. Use text notes.');
        }
      }, []);

      // Load source content and saved position when currentSource changes
      useEffect(() => {
        if (currentSource && (currentSource.type === 'article' || currentSource.type === 'pdf') && currentSource.content) {
          setContent({
            title: currentSource.title,
            sentences: currentSource.sentences || splitIntoSentences(currentSource.content),
            url: currentSource.url
          });
          sentencesRef.current = currentSource.sentences || splitIntoSentences(currentSource.content);

          // Load saved position for this source
          const savedPositions = JSON.parse(localStorage.getItem('harkenjot_positions') || '{}');
          const savedPosition = savedPositions[currentSource.id];
          if (savedPosition !== undefined && savedPosition < sentencesRef.current.length) {
            setCurrentSentenceIndex(savedPosition);
          } else {
            setCurrentSentenceIndex(0);
          }

          // Load saved speed for this source
          setSpeed(currentSource.speed || 1);
        }
      }, [currentSource]);

      // Save position whenever it changes
      useEffect(() => {
        if (currentSource?.id && content) {
          const savedPositions = JSON.parse(localStorage.getItem('harkenjot_positions') || '{}');
          savedPositions[currentSource.id] = currentSentenceIndex;
          localStorage.setItem('harkenjot_positions', JSON.stringify(savedPositions));
        }
      }, [currentSentenceIndex, currentSource?.id, content]);

      // Track isPlaying in a ref for event handlers
      const isPlayingRef = useRef(false);
      useEffect(() => {
        isPlayingRef.current = isPlaying;
      }, [isPlaying]);

      // Pause and save when page becomes hidden (browser tab switch or app close)
      useEffect(() => {
        const handleVisibilityChange = () => {
          if (document.hidden && isPlayingRef.current) {
            wasCancelledRef.current = true;
            window.speechSynthesis.cancel();
            setIsPlaying(false);
            showToast('Playback paused - position saved');
          }
        };

        const handleBeforeUnload = () => {
          if (isPlayingRef.current) {
            window.speechSynthesis.cancel();
          }
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('beforeunload', handleBeforeUnload);

        return () => {
          document.removeEventListener('visibilitychange', handleVisibilityChange);
          window.removeEventListener('beforeunload', handleBeforeUnload);
        };
      }, [showToast]);

      const splitIntoSentences = (text) => {
        return text.match(/[^.!?]+[.!?]+/g) || [text];
      };

      const extractArticleContent = (html) => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        // Remove unwanted elements
        const removeSelectors = ['script', 'style', 'nav', 'header', 'footer', 'aside', 'iframe', 'noscript', '.ad', '.advertisement', '.sidebar', '.menu', '.navigation', '.comment', '.comments'];
        removeSelectors.forEach(selector => {
          doc.querySelectorAll(selector).forEach(el => el.remove());
        });

        // Get the title
        const title = doc.querySelector('title')?.textContent ||
                      doc.querySelector('h1')?.textContent ||
                      doc.querySelector('meta[property="og:title"]')?.content ||
                      'Untitled Article';

        // Try to find main content in order of preference
        const contentSelectors = [
          'article',
          '[role="main"]',
          'main',
          '.article-content',
          '.post-content',
          '.entry-content',
          '.content',
          '.article-body',
          '.story-body',
          '#content',
          '#article'
        ];

        let contentElement = null;
        for (const selector of contentSelectors) {
          contentElement = doc.querySelector(selector);
          if (contentElement) break;
        }

        // Fall back to body if no specific content area found
        if (!contentElement) {
          contentElement = doc.body;
        }

        // Extract text from paragraphs for cleaner content
        const paragraphs = contentElement.querySelectorAll('p');
        let text = '';

        if (paragraphs.length > 3) {
          // If we have paragraphs, use them for cleaner extraction
          paragraphs.forEach(p => {
            const pText = p.textContent.trim();
            if (pText.length > 20) { // Filter out short paragraphs (likely UI elements)
              text += pText + ' ';
            }
          });
        } else {
          // Fall back to all text content
          text = contentElement.textContent;
        }

        // Clean up the text
        text = text
          .replace(/\s+/g, ' ')           // Collapse whitespace
          .replace(/\n+/g, ' ')           // Remove newlines
          .replace(/\t+/g, ' ')           // Remove tabs
          .trim();

        return { title: title.trim(), text };
      };

      const fetchContent = async () => {
        if (!url.trim()) return;

        setLoading(true);

        try {
          // Check if it's a PDF
          if (url.toLowerCase().endsWith('.pdf') || url.toLowerCase().includes('.pdf')) {
            try {
              pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
              showToast('Loading PDF...');

              // Fetch PDF as binary data - try multiple methods
              let pdfData;
              const corsProxies = [
                (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`,
                (u) => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
                (u) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`,
              ];

              // Try direct fetch first
              try {
                console.log('Trying direct PDF fetch...');
                const response = await fetch(url, { mode: 'cors' });
                if (response.ok) {
                  pdfData = await response.arrayBuffer();
                  console.log('Direct fetch succeeded');
                }
              } catch (e) {
                console.log('Direct fetch failed:', e.message);
              }

              // Try proxies if direct failed
              if (!pdfData) {
                for (const proxyFn of corsProxies) {
                  try {
                    const proxyUrl = proxyFn(url);
                    console.log('Trying proxy:', proxyUrl);
                    const response = await fetch(proxyUrl);
                    if (response.ok) {
                      pdfData = await response.arrayBuffer();
                      console.log('Proxy fetch succeeded:', pdfData.byteLength, 'bytes');
                      break;
                    }
                  } catch (e) {
                    console.log('Proxy failed:', e.message);
                  }
                }
              }

              if (!pdfData) {
                throw new Error('All fetch methods failed');
              }

              console.log('PDF data loaded:', pdfData.byteLength, 'bytes');

              // Load PDF from binary data
              const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
              console.log('PDF parsed:', pdf.numPages, 'pages');

              let fullText = '';
              for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += pageText + ' ';
              }

              if (!fullText.trim()) {
                showToast('PDF has no readable text. It may be scanned/image-based.');
                setShowManualInput(true);
                setLoading(false);
                return;
              }

              const sentences = splitIntoSentences(fullText);
              sentencesRef.current = sentences;

              const newSource = addSource({
                type: 'pdf',
                title: url.split('/').pop()?.replace('.pdf', '') || 'PDF Document',
                url: url,
                content: fullText,
                sentences: sentences
              });

              setContent({
                title: newSource.title,
                sentences: sentences,
                url: url
              });
              setUrl(''); // Clear URL after successful load
              showToast('PDF loaded successfully!');
              setLoading(false);
              return;
            } catch (error) {
              console.error('PDF fetch error:', error);
              showToast('Could not load PDF. Try pasting content manually.');
              setShowManualInput(true);
              setLoading(false);
              return;
            }
          }

          // For web articles, try multiple CORS proxies
          showToast('Fetching article content...');

          const corsProxies = [
            {
              name: 'allorigins',
              url: (u) => `https://api.allorigins.win/get?url=${encodeURIComponent(u)}`,
              extract: (data) => data.contents
            },
            {
              name: 'corsproxy.io',
              url: (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`,
              extract: (data) => data
            },
            {
              name: 'codetabs',
              url: (u) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`,
              extract: (data) => data
            }
          ];

          let html = null;
          let lastError = null;

          for (const proxy of corsProxies) {
            try {
              console.log(`Trying ${proxy.name} proxy...`);
              const proxyUrl = proxy.url(url);
              const response = await fetch(proxyUrl);

              if (!response.ok) {
                throw new Error(`${proxy.name} returned ${response.status}`);
              }

              const data = await (proxy.name === 'allorigins' ? response.json() : response.text());
              html = proxy.extract(data);

              if (html && html.length > 100) {
                console.log(`${proxy.name} succeeded`);
                break;
              }
            } catch (error) {
              console.log(`${proxy.name} failed:`, error.message);
              lastError = error;
            }
          }

          if (!html) {
            throw lastError || new Error('All proxies failed');
          }

          const { title, text } = extractArticleContent(html);

          if (text.length < 100) {
            showToast('Could not extract enough content. Try pasting manually.');
            setShowManualInput(true);
            setLoading(false);
            return;
          }

          const sentences = splitIntoSentences(text);
          sentencesRef.current = sentences;

          const newSource = addSource({
            type: 'article',
            title: title,
            url: url,
            content: text,
            sentences: sentences
          });

          setContent({
            title: newSource.title,
            sentences: sentences,
            url: url
          });

          setUrl(''); // Clear URL after successful load
          showToast('Article loaded successfully!');

        } catch (error) {
          console.error('Fetch error:', error);
          showToast('Could not fetch content. Try pasting manually.');
          setShowManualInput(true);
        }

        setLoading(false);
      };

      const handleManualSubmit = () => {
        if (!manualContent.trim()) return;
        
        const sentences = splitIntoSentences(manualContent);
        sentencesRef.current = sentences;
        
        const newSource = addSource({
          type: 'article',
          title: url || 'Pasted Content',
          url: url || null,
          content: manualContent,
          sentences: sentences
        });
        
        setContent({
          title: newSource.title,
          sentences: sentences,
          url: url
        });

        setUrl(''); // Clear URL after successful load
        setShowManualInput(false);
        setManualContent('');
      };

      // Wake Lock helpers to keep screen on during playback
      const requestWakeLock = async () => {
        try {
          if ('wakeLock' in navigator) {
            // Release old wake lock if it exists
            if (wakeLockRef.current) {
              try {
                await wakeLockRef.current.release();
              } catch (e) {
                // Ignore errors from releasing
              }
            }

            // Always request fresh wake lock (handles screen on/off cycles)
            wakeLockRef.current = await navigator.wakeLock.request('screen');
            console.log('Wake Lock activated');

            // Listen for release event to clear the ref
            wakeLockRef.current.addEventListener('release', () => {
              console.log('Wake Lock was released');
              wakeLockRef.current = null;
            });
          }
        } catch (err) {
          console.log('Wake Lock not supported or failed:', err);
          wakeLockRef.current = null;
        }
      };

      const releaseWakeLock = async () => {
        try {
          if (wakeLockRef.current) {
            await wakeLockRef.current.release();
            wakeLockRef.current = null;
            console.log('Wake Lock released');
          }
        } catch (err) {
          console.log('Wake Lock release failed:', err);
        }
      };

      const togglePlayback = () => {
        if (isPlaying) {
          wasCancelledRef.current = true;
          window.speechSynthesis.cancel();
          setIsPlaying(false);
          releaseWakeLock();
        } else {
          setAutoScroll(true);
          speakFromIndex(currentSentenceIndex);
        }
      };

      // Get best available voice (prioritize Google, then Microsoft)
      const getBestVoice = () => {
        const voices = window.speechSynthesis.getVoices();
        if (!voices.length) return null;

        // Filter for English voices only
        const englishVoices = voices.filter(voice => voice.lang.startsWith('en'));

        // Prioritize Google voices
        const googleVoice = englishVoices.find(voice => voice.name.includes('Google'));
        if (googleVoice) return googleVoice;

        // Then Microsoft voices (prefer ones with "Online" or newer versions)
        const microsoftVoice = englishVoices.find(voice =>
          voice.name.includes('Microsoft') &&
          (voice.name.includes('Online') || voice.name.includes('Natural'))
        );
        if (microsoftVoice) return microsoftVoice;

        // Fall back to any Microsoft voice
        const anyMicrosoftVoice = englishVoices.find(voice => voice.name.includes('Microsoft'));
        if (anyMicrosoftVoice) return anyMicrosoftVoice;

        // Fall back to first English voice
        return englishVoices[0] || voices[0];
      };

      const speakFromIndex = useCallback((index) => {
        if (!content || index >= content.sentences.length) {
          setIsPlaying(false);
          releaseWakeLock();
          return;
        }

        wasCancelledRef.current = false;
        setIsPlaying(true);
        requestWakeLock(); // Keep screen on during playback
        setCurrentSentenceIndex(index);
        const utterance = new SpeechSynthesisUtterance(content.sentences[index]);
        utterance.rate = speed;

        // Set best available voice
        const bestVoice = getBestVoice();
        if (bestVoice) {
          utterance.voice = bestVoice;
        }

        utterance.onend = () => {
          // Don't continue if speech was intentionally cancelled
          if (wasCancelledRef.current) {
            wasCancelledRef.current = false;
            releaseWakeLock();
            return;
          }
          const nextIndex = index + 1;
          setCurrentSentenceIndex(nextIndex);
          if (nextIndex < content.sentences.length && speakFromIndexRef.current) {
            speakFromIndexRef.current(nextIndex);
          } else {
            setIsPlaying(false);
            releaseWakeLock(); // Release when playback ends
            // Auto-mark as read when reaching the end
            if (currentSource?.id && !currentSource.isRead) {
              updateSource(currentSource.id, { isRead: true });
            }
          }
        };

        utteranceRef.current = utterance;
        window.speechSynthesis.speak(utterance);
      }, [content, speed, currentSource, updateSource]);

      // Keep the ref updated with the latest speakFromIndex function
      useEffect(() => {
        speakFromIndexRef.current = speakFromIndex;
      }, [speakFromIndex]);

      // Apply speed changes immediately while playing
      const prevSpeedRef = useRef(speed);
      useEffect(() => {
        if (prevSpeedRef.current !== speed && isPlaying && speakFromIndexRef.current) {
          // Cancel current speech and restart from current sentence with new speed
          wasCancelledRef.current = true;
          window.speechSynthesis.cancel();
          // Small delay to ensure cancel completes before restarting
          setTimeout(() => {
            speakFromIndexRef.current(currentSentenceIndex);
          }, 50);
        }
        prevSpeedRef.current = speed;
      }, [speed, isPlaying, currentSentenceIndex]);

      // Save speed to source when it changes
      useEffect(() => {
        if (currentSource?.id && speed !== 1) {
          updateSource(currentSource.id, { speed: speed });
        }
      }, [speed, currentSource?.id]);

      // Media Session API for Android Auto / lock screen controls (TTS)
      useEffect(() => {
        if (!('mediaSession' in navigator)) return;

        if (content && currentSource) {
          // Set up action handlers for TTS
          MediaSessionManager.setActionHandlers({
            onPlay: () => {
              if (!isPlaying && speakFromIndexRef.current) {
                speakFromIndexRef.current(currentSentenceIndex);
              }
            },
            onPause: () => {
              if (isPlaying) {
                wasCancelledRef.current = true;
                window.speechSynthesis.cancel();
                setIsPlaying(false);
                releaseWakeLock();
              }
            },
            onSeekBackward: () => skipBack(),
            onSeekForward: () => skipForward(),
            onPreviousTrack: () => {
              // Go to beginning
              wasCancelledRef.current = true;
              window.speechSynthesis.cancel();
              setCurrentSentenceIndex(0);
              if (isPlaying && speakFromIndexRef.current) {
                setTimeout(() => speakFromIndexRef.current(0), 50);
              }
            },
            onNextTrack: null
          });

          // Set metadata
          MediaSessionManager.setMetadata({
            title: content.title || currentSource.title || 'Article',
            artist: currentSource.siteName || 'HarkenJot Reader',
            album: currentSource.type === 'pdf' ? 'PDF' : 'Article',
            artwork: null
          });
        }

        return () => {
          MediaSessionManager.clearHandlers();
        };
      }, [content, currentSource]);

      // Start/stop silent audio and update playback state for TTS media session
      useEffect(() => {
        if (!('mediaSession' in navigator)) return;

        if (isPlaying && content) {
          // Start silent audio to activate media session
          const silentAudio = MediaSessionManager.initSilentAudio();
          silentAudio.play().catch(err => console.log('Silent audio play error:', err));
          MediaSessionManager.setPlaybackState('playing');
        } else {
          MediaSessionManager.stopSilentAudio();
          if (content) {
            MediaSessionManager.setPlaybackState('paused');
          }
        }

        return () => {
          MediaSessionManager.stopSilentAudio();
        };
      }, [isPlaying, content]);

      // Update Media Session position state for TTS (sentence-based progress)
      useEffect(() => {
        if (!('mediaSession' in navigator) || !content) return;

        // Approximate duration: 3 seconds per sentence at 1x speed
        const estimatedDuration = content.sentences.length * 3;
        const estimatedPosition = currentSentenceIndex * 3;

        MediaSessionManager.setPositionState({
          duration: estimatedDuration,
          position: estimatedPosition,
          playbackRate: speed
        });
      }, [currentSentenceIndex, content, speed]);

      const audioContextRef = useRef(null);
      const analyzerRef = useRef(null);
      const silenceTimeoutRef = useRef(null);
      const isProcessing = isRecording || isTranscribing || whisperLoading;

      const stopRecording = () => {
        // Stop Web Speech API recognition or MediaRecorder (Whisper mode)
        if (mediaRecorderRef.current) {
          try {
            playSound('stop');
            mediaRecorderRef.current.stop();
          } catch (err) {
            console.log('Error stopping recognition:', err);
          }
          mediaRecorderRef.current = null;
        }
        // Clean up audio stream if using Whisper
        if (streamRef.current) {
          streamRef.current.getTracks().forEach(track => track.stop());
          streamRef.current = null;
        }
      };

      const handleVoiceButtonClick = () => {
        if (isRecording) {
          stopRecording();
        } else if (isTranscribing || whisperLoading) {
          // Provide feedback that we're busy
          playSound('error');
          showToast(whisperLoading ? 'Loading speech model...' : 'Still processing...');
        } else if (isStartingRecordingRef.current) {
          // Prevent concurrent startRecording calls
          playSound('error');
          showToast('Please wait, starting recording...');
        } else {
          startRecording();
        }
      };

      // Load Whisper model for fallback
      const loadWhisperModel = async () => {
        if (window.WhisperASR?.isReady) {
          setUseWhisperFallback(true);
          return true;
        }
        if (whisperLoading) return false;

        setWhisperLoading(true);
        showToast('Loading offline speech model (40MB)...');

        const success = await window.WhisperASR?.loadModel((progress) => {
          setWhisperProgress(progress);
        });

        setWhisperLoading(false);
        if (success) {
          setUseWhisperFallback(true);
          showToast('Offline speech model ready!');
          return true;
        } else {
          showToast('Failed to load offline model');
          return false;
        }
      };

      // Start recording using Whisper (MediaRecorder-based) with silence detection
      const startWhisperRecording = async (wasPlaying, notePosition) => {
        try {
          const audioConstraints = {
            audio: {
              echoCancellation: { ideal: true },
              noiseSuppression: { ideal: true },
              autoGainControl: { ideal: true },
              channelCount: { ideal: 1 },
              sampleRate: { ideal: 16000 }
            }
          };
          const stream = await navigator.mediaDevices.getUserMedia(audioConstraints);
          streamRef.current = stream;

          // Set up silence detection using Web Audio API
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          audioContextRef.current = audioContext;
          const analyser = audioContext.createAnalyser();
          analyzerRef.current = analyser;
          analyser.fftSize = 512;
          analyser.smoothingTimeConstant = 0.1;

          const source = audioContext.createMediaStreamSource(stream);
          source.connect(analyser);

          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          let silenceStart = null;
          let hasDetectedSpeech = false;
          const SILENCE_THRESHOLD = 15; // Audio level below this is considered silence
          const SILENCE_DURATION = 1000; // Stop after 1 second of silence
          const MAX_RECORDING_TIME = 60000; // Maximum 60 seconds
          const recordingStartTime = Date.now();

          const mimeType = window.WhisperASR?.getSupportedMimeType() || '';
          const mediaRecorder = mimeType
            ? new MediaRecorder(stream, { mimeType })
            : new MediaRecorder(stream);
          mediaRecorderRef.current = mediaRecorder;

          const audioChunks = [];

          // Silence detection loop
          const checkSilence = () => {
            if (!mediaRecorderRef.current || mediaRecorderRef.current.state !== 'recording') {
              return;
            }

            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

            // Check for max recording time
            if (Date.now() - recordingStartTime > MAX_RECORDING_TIME) {
              console.log('Max recording time reached, stopping');
              mediaRecorderRef.current.stop();
              return;
            }

            if (average > SILENCE_THRESHOLD) {
              // Sound detected
              hasDetectedSpeech = true;
              silenceStart = null;
            } else if (hasDetectedSpeech) {
              // Silence after speech
              if (!silenceStart) {
                silenceStart = Date.now();
              } else if (Date.now() - silenceStart > SILENCE_DURATION) {
                console.log('Silence detected for 2 seconds, stopping recording');
                mediaRecorderRef.current.stop();
                return;
              }
            }

            silenceTimeoutRef.current = requestAnimationFrame(checkSilence);
          };

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunks.push(event.data);
            }
          };

          mediaRecorder.onerror = (event) => {
            console.error('MediaRecorder error:', event.error);
            if (silenceTimeoutRef.current) {
              cancelAnimationFrame(silenceTimeoutRef.current);
            }
            if (audioContextRef.current) {
              audioContextRef.current.close().catch(() => {});
            }
            showToast('Recording error. Try again.');
            stream.getTracks().forEach(track => track.stop());
            setIsRecording(false);
            isStartingRecordingRef.current = false;
          };

          mediaRecorder.onstop = async () => {
            // Clean up silence detection
            if (silenceTimeoutRef.current) {
              cancelAnimationFrame(silenceTimeoutRef.current);
            }
            if (audioContextRef.current) {
              audioContextRef.current.close().catch(() => {});
              audioContextRef.current = null;
            }

            stream.getTracks().forEach(track => track.stop());
            streamRef.current = null;

            if (audioChunks.length === 0) {
              playSound('error');
              showToast('No audio captured. Try again.');
              setIsRecording(false);
              if (wasPlaying && speakFromIndexRef.current) {
                setTimeout(() => speakFromIndexRef.current(notePosition), 300);
              }
              return;
            }

            const audioBlob = new Blob(audioChunks, { type: mimeType || 'audio/webm' });

            if (audioBlob.size < 500) {
              playSound('error');
              showToast('Recording too short. Try again.');
              setIsRecording(false);
              if (wasPlaying && speakFromIndexRef.current) {
                setTimeout(() => speakFromIndexRef.current(notePosition), 300);
              }
              return;
            }

            setIsRecording(false);
            setIsTranscribing(true);

            try {
              const transcript = await window.WhisperASR.transcribe(audioBlob);
              if (transcript && transcript.trim()) {
                const sentence = sentencesRef.current[notePosition];
                addNote({
                  sourceId: currentSource?.id,
                  text: transcript.trim(),
                  position: notePosition,
                  context: sentence?.substring(0, 100) + '...',
                  type: 'voice'
                });
                playSound('success');
                showToast('Note saved!');
              } else {
                playSound('error');
                showToast('No speech detected - try speaking louder');
              }
            } catch (error) {
              console.error('Transcription failed:', error);
              playSound('error');
              showToast('Transcription failed. Try again.');
            }
            setIsTranscribing(false);

            if (wasPlaying && speakFromIndexRef.current) {
              setTimeout(() => speakFromIndexRef.current(notePosition), 300);
            }
          };

          mediaRecorder.start(100);
          setIsRecording(true);
          isStartingRecordingRef.current = false;
          playSound('start');
          showToast('Listening (offline mode)...');

          // Start silence detection
          checkSilence();
        } catch (error) {
          console.error('Failed to start Whisper recording:', error);
          playSound('error');
          showToast('Failed to access microphone');
          setIsRecording(false);
          isStartingRecordingRef.current = false;
        }
      };

      const startRecording = async () => {
        console.log('=== startRecording called ===');
        console.log('speechReady:', speechReady, 'useWhisperFallback:', useWhisperFallback);

        if (!speechReady) {
          playSound('error');
          showToast('Speech recognition not available. Use text notes.');
          return;
        }

        if (isStartingRecordingRef.current) {
          return;
        }
        isStartingRecordingRef.current = true;

        stopRecording();

        const wasPlaying = isPlaying;
        const notePosition = currentSentenceIndex;

        if (isPlaying || window.speechSynthesis.speaking) {
          wasCancelledRef.current = true;
          window.speechSynthesis.cancel();
          setIsPlaying(false);
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        // Use Whisper if fallback is enabled or Web Speech has had network errors
        if (useWhisperFallback || window.WebSpeechAPI?.hasNetworkError) {
          if (!window.WhisperASR?.isReady) {
            const loaded = await loadWhisperModel();
            if (!loaded) {
              isStartingRecordingRef.current = false;
              return;
            }
          }
          await startWhisperRecording(wasPlaying, notePosition);
          return;
        }

        // Try Web Speech API (primary)
        try {
          const recognition = window.WebSpeechAPI.createRecognition({
            continuous: false,
            interimResults: true,
            lang: 'en-US'
          });

          let finalTranscript = '';
          let hasResult = false;
          let hadError = false;

          recognition.onstart = () => {
            console.log('Web Speech recognition started');
            setIsRecording(true);
            isStartingRecordingRef.current = false;
            playSound('start');
            showToast('Listening...');
          };

          recognition.onresult = (event) => {
            hasResult = true;
            let interimTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
              const transcript = event.results[i][0].transcript;
              if (event.results[i].isFinal) {
                finalTranscript += transcript;
              } else {
                interimTranscript += transcript;
              }
            }
            console.log('Interim:', interimTranscript, 'Final:', finalTranscript);
          };

          recognition.onend = () => {
            console.log('Web Speech recognition ended');
            setIsRecording(false);
            isStartingRecordingRef.current = false;

            if (hadError) {
              console.log('Skipping onend message - error already handled');
            } else if (finalTranscript.trim()) {
              const sentence = sentencesRef.current[notePosition];
              addNote({
                sourceId: currentSource?.id,
                text: finalTranscript.trim(),
                position: notePosition,
                context: sentence?.substring(0, 100) + '...',
                type: 'voice'
              });
              playSound('success');
              showToast('Note saved!');
            } else if (hasResult) {
              playSound('error');
              showToast('No speech detected - try again');
            } else {
              playSound('error');
              showToast('No speech detected - try speaking louder');
            }

            if (wasPlaying && speakFromIndexRef.current) {
              setTimeout(() => speakFromIndexRef.current(notePosition), 300);
            }
          };

          recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            hadError = true;
            setIsRecording(false);
            isStartingRecordingRef.current = false;

            if (event.error === 'network') {
              // Network error - offer Whisper fallback
              window.WebSpeechAPI.markNetworkError();
              playSound('error');
              showToast('Network error - switching to offline mode...');
              // Automatically try to load Whisper and retry
              loadWhisperModel().then(success => {
                if (success) {
                  showToast('Offline mode ready! Try recording again.');
                }
              });
            } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
              playSound('error');
              showToast('Microphone access denied');
            } else if (event.error === 'no-speech') {
              playSound('error');
              showToast('No speech detected - try again');
            } else if (event.error === 'aborted') {
              playSound('error');
              showToast('Speech recognition interrupted. Try again.');
            } else if (event.error === 'audio-capture') {
              playSound('error');
              showToast('No microphone found. Check your audio settings.');
            } else {
              playSound('error');
              showToast(`Speech recognition error: ${event.error}`);
            }

            if (wasPlaying && speakFromIndexRef.current) {
              setTimeout(() => speakFromIndexRef.current(notePosition), 300);
            }
          };

          mediaRecorderRef.current = recognition;
          recognition.start();
        } catch (error) {
          console.error('Failed to start speech recognition:', error);
          playSound('error');
          showToast('Speech recognition failed to start');
          setIsRecording(false);
          isStartingRecordingRef.current = false;
        }
      };

      const saveTextNote = () => {
        if (textNote.trim()) {
          const sentence = sentencesRef.current[currentSentenceIndex];
          addNote({
            sourceId: currentSource?.id,
            text: textNote.trim(),
            position: currentSentenceIndex,
            context: sentence?.substring(0, 100) + '...',
            type: 'text'
          });
          setTextNote('');
          setShowTextNote(false);
        }

        // Resume playback if it was playing before
        if (wasPlayingRef.current && speakFromIndexRef.current) {
          setTimeout(() => speakFromIndexRef.current(currentSentenceIndex), 100);
          wasPlayingRef.current = false;
        }
      };

      const cancelTextNote = () => {
        setShowTextNote(false);
        setTextNote('');

        // Resume playback if it was playing before
        if (wasPlayingRef.current && speakFromIndexRef.current) {
          setTimeout(() => speakFromIndexRef.current(currentSentenceIndex), 100);
          wasPlayingRef.current = false;
        }
      };

      const openTextNote = () => {
        // Store playback state and pause if playing
        if (isPlaying) {
          wasPlayingRef.current = true;
          wasCancelledRef.current = true;
          window.speechSynthesis.cancel();
          setIsPlaying(false);
        } else {
          wasPlayingRef.current = false;
        }
        setShowTextNote(true);
      };

      const progress = content ? (currentSentenceIndex / content.sentences.length) * 100 : 0;
      const notedSentences = new Set(notes.map(n => n.position));

      return (
        <div style={{ display: 'flex', flexDirection: 'column', flex: 1, minHeight: 0, overflow: 'hidden' }}>
          <div className="input-section" style={{ display: carMode ? 'none' : 'block' }}>
            <div className="input-group">
              <input
                type="text"
                className="url-input"
                placeholder="Paste article or PDF link..."
                value={url}
                onChange={(e) => setUrl(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && fetchContent()}
              />
              <button className="btn btn-primary" onClick={fetchContent} disabled={loading}>
                {loading ? 'Loading...' : <><Icons.Link /> Load</>}
              </button>
            </div>

            {showManualInput && (
              <div style={{ marginTop: '0.5rem' }}>
                <textarea
                  className="url-input"
                  style={{ width: '100%', minHeight: '100px', resize: 'vertical' }}
                  placeholder="Paste article content here..."
                  value={manualContent}
                  onChange={(e) => setManualContent(e.target.value)}
                />
                <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem' }}>
                  <button className="btn btn-primary" onClick={handleManualSubmit}>
                    <Icons.Plus /> Add to Library
                  </button>
                  <button className="btn btn-secondary" onClick={() => setShowManualInput(false)}>
                    Cancel
                  </button>
                </div>
              </div>
            )}
          </div>

          {content ? (
            <div className="reader-container">
              <div className="reader-header">
                <div className="source-info" style={{ flex: 1 }}>
                  <div style={{ display: 'flex', alignItems: 'flex-start', gap: '1rem' }}>
                    <EditableTitle
                      title={content.title}
                      onSave={(newTitle) => {
                        if (currentSource) {
                          updateSource(currentSource.id, { title: newTitle });
                        }
                        setContent(prev => ({ ...prev, title: newTitle }));
                      }}
                    />
                    {currentSource && (
                      <div
                        className={`read-status clickable ${currentSource.isRead ? 'checked' : ''}`}
                        onClick={() => updateSource(currentSource.id, { isRead: !currentSource.isRead })}
                        title={currentSource.isRead ? 'Mark as unread' : 'Mark as read'}
                        style={{ marginTop: '0.25rem' }}
                      >
                        {currentSource.isRead && <Icons.Check />}
                      </div>
                    )}
                  </div>
                  <div className="source-meta">
                    <span className={`library-item-type ${currentSource?.type || 'article'}`}>{currentSource?.type || 'Article'}</span>
                    {content.url && <span className="source-name">{safeHostname(content.url)}</span>}
                    <span>{content.sentences.length} sentences</span>
                    {content.url && <a href={content.url} target="_blank" rel="noopener noreferrer"><Icons.Link /></a>}
                  </div>
                </div>
              </div>
              
              <div className="reader-body" ref={readerContainerRef} style={{ display: carMode ? 'none' : 'block' }}>
                <div className="reader-content">
                  {content.sentences.map((sentence, index) => (
                    <span
                      key={index}
                      ref={(el) => sentenceRefs.current[index] = el}
                      className={`sentence ${index === currentSentenceIndex ? 'current' : ''} ${notedSentences.has(index) ? 'has-note' : ''}`}
                      onClick={() => setCurrentSentenceIndex(index)}
                    >
                      {sentence}{' '}
                    </span>
                  ))}
                </div>
              </div>
              
              {showTextNote && (
                <div className="text-note-container">
                  <input
                    type="text"
                    className="url-input text-note-input"
                    placeholder="Type your note..."
                    value={textNote}
                    onChange={(e) => setTextNote(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && saveTextNote()}
                    autoFocus
                  />
                  <div className="text-note-buttons">
                    <button className="btn btn-primary" onClick={saveTextNote}>Save</button>
                    <button className="btn btn-secondary" onClick={cancelTextNote}>Cancel</button>
                  </div>
                </div>
              )}

              {showSearch && (
                <div className="search-container">
                  <input
                    type="text"
                    className="url-input"
                    placeholder="Search in text..."
                    value={searchQuery}
                    onChange={(e) => handleSearch(e.target.value)}
                    autoFocus
                  />
                  <button className="btn btn-secondary" onClick={() => setShowSearch(false)}>Close</button>
                  {searchResults.length > 0 && (
                    <div className="search-results">
                      <div style={{ fontSize: '0.875rem', fontWeight: 500, marginBottom: '0.5rem' }}>
                        {searchResults.length} result{searchResults.length !== 1 ? 's' : ''}
                      </div>
                      {searchResults.map((result, idx) => (
                        <div
                          key={idx}
                          className="search-result-item"
                          onClick={() => navigateToSearchResult(result.index)}
                        >
                          <div style={{ fontSize: '0.75rem', color: 'var(--accent)', fontWeight: 500 }}>
                            Sentence {result.index + 1}
                          </div>
                          <div style={{ fontSize: '0.875rem' }}>
                            {result.sentence.substring(0, 150)}{result.sentence.length > 150 ? '...' : ''}
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                  {searchQuery && searchResults.length === 0 && (
                    <div style={{ padding: '1rem', textAlign: 'center', color: 'var(--text-muted)', fontSize: '0.875rem' }}>
                      No results found
                    </div>
                  )}
                </div>
              )}
              <div className={`playback-bar ${carMode ? 'car-mode' : ''}`}>
                <div className="playback-controls">
                  <div className="transport-buttons">
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={skipBack}
                      title="Restart sentence / Previous (double-tap)"
                    >
                      <Icons.SkipBack />
                    </button>
                    <button className={`play-btn ${carMode ? 'car-mode' : ''}`} onClick={togglePlayback}>
                      {isPlaying ? <Icons.Pause /> : <Icons.Play />}
                    </button>
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={skipForward}
                      disabled={currentSentenceIndex === content.sentences.length - 1}
                      title="Next sentence"
                    >
                      <Icons.SkipForward />
                    </button>
                  </div>

                  <div className={`progress-speed-group ${carMode ? 'car-mode' : ''}`}>
                    <div className="progress-container">
                      <div className={`progress-bar ${carMode ? 'car-mode' : ''}`}>
                        <div className="progress-fill" style={{ width: `${progress}%` }} />
                      </div>
                      <div className="progress-text">
                        <span>Sentence {currentSentenceIndex + 1} of {content.sentences.length}</span>
                        <span>{Math.round(progress)}%</span>
                      </div>
                    </div>

                    <div className={`speed-control ${carMode ? 'car-mode' : ''}`}>
                      <label>Speed</label>
                      <select value={speed} onChange={(e) => setSpeed(parseFloat(e.target.value))}>
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1">1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                      </select>
                    </div>
                  </div>
                </div>

                <div className="note-controls">
                  <button
                    className={`note-btn ${isProcessing ? 'processing' : ''} ${carMode ? 'car-mode' : ''}`}
                    onClick={handleVoiceButtonClick}
                    disabled={!speechReady || whisperLoading}
                    title={!speechReady ? 'Speech recognition not supported' : (useWhisperFallback ? 'Using offline mode' : '')}
                  >
                    {isRecording ? ' Stop' :
                     whisperLoading ? `Loading ${whisperProgress}%` :
                     isTranscribing ? 'Processing...' :
                     <><Icons.Mic /> Voice{useWhisperFallback ? ' (offline)' : ''}</>}
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    onClick={openTextNote}
                  >
                    <Icons.Keyboard /> Type
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    onClick={() => setShowSearch(!showSearch)}
                  >
                    <Icons.Search /> Search
                  </button>
                  {isMobileDevice && (
                    <button
                      className={`note-btn ${carMode ? 'car-mode active' : ''}`}
                      onClick={() => setCarMode(!carMode)}
                      title="Car Mode"
                    >
                      <Icons.Car />
                    </button>
                  )}
                </div>
              </div>
            </div>
          ) : (
            <div className="empty-state">
              <div className="empty-state-icon"></div>
              <h3>Article Reader</h3>
              <p>Paste an article or PDF link above to begin. The app will read it aloud and let you take notes while you listen.</p>
            </div>
          )}
        </div>
      );
    });

    // Media View Component
    const MediaView = React.forwardRef(({ currentSource, setCurrentSource, addSource, updateSource, addNote, notes, showToast, setActiveTab, carMode, setCarMode, isMobileDevice }, ref) => {
      const [url, setUrl] = useState('');
      const [isPlaying, setIsPlaying] = useState(false);
      const [currentTime, setCurrentTime] = useState(0);
      const [duration, setDuration] = useState(0);
      const [isRecording, setIsRecording] = useState(false);
      const [videoId, setVideoId] = useState(null);
      const [podcastAudio, setPodcastAudio] = useState(null); // { audioUrl, title, showName, artworkUrl, link }
      const [isLoadingPodcast, setIsLoadingPodcast] = useState(false);
      const [speechReady, setSpeechReady] = useState(false);
      const [useWhisperFallback, setUseWhisperFallback] = useState(false);
      const [whisperLoading, setWhisperLoading] = useState(false);
      const [whisperProgress, setWhisperProgress] = useState(0);
      const [isTranscribing, setIsTranscribing] = useState(false);
      const [showTextNote, setShowTextNote] = useState(false);
      const [textNote, setTextNote] = useState('');
      const [speed, setSpeed] = useState(1);
      const [artworkFailed, setArtworkFailed] = useState(false);
      const [isLoadingArtwork, setIsLoadingArtwork] = useState(false);

      const playerRef = useRef(null);
      const audioPlayerRef = useRef(null); // HTML5 audio element for podcasts
      const mediaRecorderRef = useRef(null);
      const streamRef = useRef(null);
      const intervalRef = useRef(null);
      const isStartingRecordingRef = useRef(false);
      const lastInitializedSourceRef = useRef(null); // Track last initialized source to prevent re-init loops
      const wasPlayingRef = useRef(false);

      // Expose seekTo method to parent
      useImperativeHandle(ref, () => ({
        seekTo: (timestamp) => {
          if (playerRef.current) {
            playerRef.current.seekTo(timestamp, true);
          } else if (audioPlayerRef.current) {
            audioPlayerRef.current.currentTime = timestamp;
          }
        }
      }));
      const wakeLockRef = useRef(null);
      const audioContextRef = useRef(null);
      const analyzerRef = useRef(null);
      const silenceTimeoutRef = useRef(null);
      const isProcessing = isRecording || isTranscribing || whisperLoading;

      // Load currentSource into player when source is selected from library
      useEffect(() => {
        if (currentSource && currentSource.type === 'youtube' && currentSource.videoId) {
          // Skip if we already initialized for this source (prevents loop when updateSource updates currentSource)
          if (lastInitializedSourceRef.current === currentSource.id) {
            return;
          }
          lastInitializedSourceRef.current = currentSource.id;

          setVideoId(currentSource.videoId);
          setPodcastAudio(null);
          setSpeed(currentSource.speed || 1);
          // Don't set URL - keep input clear after loading
          // Initialize player after state update
          setTimeout(() => {
            if (window.YT && window.YT.Player) {
              initPlayer(currentSource.videoId);
              // Restore saved position after player is ready (without auto-playing)
              setTimeout(() => {
                if (playerRef.current) {
                  const savedPositions = JSON.parse(localStorage.getItem('harkenjot_media_positions') || '{}');
                  const savedPosition = savedPositions[currentSource.id];
                  if (savedPosition) {
                    playerRef.current.seekTo(savedPosition, true);
                    playerRef.current.pauseVideo(); // Don't auto-play, just cue up
                    setCurrentTime(savedPosition); // Update progress bar immediately
                  }
                }
              }, 500);
            }
          }, 100);
        } else if (currentSource && currentSource.type === 'podcast') {
          // Skip if we already initialized for this source (prevents loop when updateSource updates currentSource)
          if (lastInitializedSourceRef.current === currentSource.id) {
            return;
          }
          lastInitializedSourceRef.current = currentSource.id;

          // Check if audioUrl is missing (older sources might not have it)
          if (!currentSource.audioUrl) {
            showToast('This podcast is missing its audio URL - please re-add it from the original link');
            setVideoId(null);
            setPodcastAudio(null);
            return;
          }

          setVideoId(null);
          setArtworkFailed(false);
          setPodcastAudio({
            audioUrl: currentSource.audioUrl,
            title: currentSource.title,
            showName: currentSource.showName || '',
            artworkUrl: currentSource.artworkUrl || '',
            link: currentSource.link || currentSource.url
          });
          setSpeed(currentSource.speed || 1);
          // Don't set URL - keep input clear after loading
          // Restore saved position after audio loads
          setTimeout(() => {
            if (audioPlayerRef.current) {
              const savedPositions = JSON.parse(localStorage.getItem('harkenjot_media_positions') || '{}');
              const savedPosition = savedPositions[currentSource.id];
              if (savedPosition) {
                audioPlayerRef.current.currentTime = savedPosition;
              }
            }
          }, 500);
        } else {
          // Reset the ref when switching to a different type or no source
          lastInitializedSourceRef.current = null;
        }
      }, [currentSource]);

      // Check if Web Speech API is ready
      useEffect(() => {
        if (window.WebSpeechAPI?.isSupported) {
          setSpeechReady(true);
          console.log('MediaView: Web Speech API ready');
          // Check if we previously had network errors and Whisper is loaded
          if (window.WebSpeechAPI.hasNetworkError && window.WhisperASR?.isReady) {
            setUseWhisperFallback(true);
            console.log('MediaView: Using Whisper fallback due to previous network errors');
          }
        } else if (window.WhisperASR) {
          console.log('MediaView: Web Speech API not supported, Whisper fallback available');
          setSpeechReady(true);
          setUseWhisperFallback(true);
        } else {
          console.log('MediaView: No speech recognition available');
          showToast('Speech recognition not supported in this browser. Use text notes.');
        }
      }, []);

      // Initialize YouTube API
      useEffect(() => {
        if (!window.YT) {
          const tag = document.createElement('script');
          tag.src = 'https://www.youtube.com/iframe_api';
          const firstScriptTag = document.getElementsByTagName('script')[0];
          firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        }
      }, []);

      // Apply playback speed to YouTube and audio players
      useEffect(() => {
        if (playerRef.current && playerRef.current.setPlaybackRate) {
          playerRef.current.setPlaybackRate(speed);
        }
        if (audioPlayerRef.current) {
          audioPlayerRef.current.playbackRate = speed;
        }
      }, [speed]);

      // Save speed to source when it changes
      useEffect(() => {
        if (currentSource?.id && speed !== 1) {
          updateSource(currentSource.id, { speed: speed });
        }
      }, [speed, currentSource?.id]);

      // Save position whenever it changes (for both YouTube and podcast)
      useEffect(() => {
        if (currentSource?.id && (videoId || podcastAudio) && currentTime > 0) {
          const savedPositions = JSON.parse(localStorage.getItem('harkenjot_media_positions') || '{}');
          savedPositions[currentSource.id] = currentTime;
          localStorage.setItem('harkenjot_media_positions', JSON.stringify(savedPositions));
        }
      }, [currentTime, currentSource?.id, videoId, podcastAudio]);

      // Pause and save when page becomes hidden
      useEffect(() => {
        const handleVisibilityChange = () => {
          if (document.hidden && isPlaying && playerRef.current) {
            playerRef.current.pauseVideo();
            showToast('Playback paused - position saved');
          }
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);

        return () => {
          document.removeEventListener('visibilitychange', handleVisibilityChange);
          // Note: Removed pauseVideo() from cleanup - it was causing YouTube to stop
          // immediately after resuming because this cleanup runs on every isPlaying change
        };
      }, [isPlaying, showToast]);

      // Track playing state before car mode changes (but not during recording)
      useEffect(() => {
        if (!isRecording && !isTranscribing) {
          wasPlayingRef.current = isPlaying;
        }
      }, [isPlaying, isRecording, isTranscribing]);

      // Media Session API for Android Auto / lock screen controls (podcasts and YouTube)
      useEffect(() => {
        if (!('mediaSession' in navigator)) return;

        // Set up action handlers based on current media type
        if (podcastAudio) {
          // Podcast: Use HTML5 audio element
          MediaSessionManager.setActionHandlers({
            onPlay: () => audioPlayerRef.current?.play(),
            onPause: () => audioPlayerRef.current?.pause(),
            onSeekBackward: () => { if (audioPlayerRef.current) audioPlayerRef.current.currentTime -= 15; },
            onSeekForward: () => { if (audioPlayerRef.current) audioPlayerRef.current.currentTime += 15; },
            onPreviousTrack: () => { if (audioPlayerRef.current) audioPlayerRef.current.currentTime = 0; },
            onNextTrack: null
          });

          // Set metadata
          MediaSessionManager.setMetadata({
            title: podcastAudio.title || 'Podcast',
            artist: podcastAudio.showName || 'HarkenJot',
            album: 'Podcast',
            artwork: podcastAudio.artworkUrl || null
          });
        } else if (videoId && playerRef.current) {
          // YouTube: Use YouTube player
          MediaSessionManager.setActionHandlers({
            onPlay: () => playerRef.current?.playVideo(),
            onPause: () => playerRef.current?.pauseVideo(),
            onSeekBackward: () => skipTime(-15),
            onSeekForward: () => skipTime(15),
            onPreviousTrack: () => playerRef.current?.seekTo(0, true),
            onNextTrack: null
          });

          // Set metadata for YouTube
          MediaSessionManager.setMetadata({
            title: currentSource?.title || 'YouTube Video',
            artist: 'YouTube',
            album: 'HarkenJot',
            artwork: currentSource?.thumbnail || null
          });
        }

        // Cleanup handlers when unmounting or switching media
        return () => {
          MediaSessionManager.clearHandlers();
        };
      }, [podcastAudio, videoId, currentSource]);

      // Update Media Session playback state when playing status changes
      useEffect(() => {
        if (podcastAudio || videoId) {
          MediaSessionManager.setPlaybackState(isPlaying ? 'playing' : 'paused');
        }
      }, [isPlaying, podcastAudio, videoId]);

      // Update Media Session position state when time/duration changes
      useEffect(() => {
        if ((podcastAudio || videoId) && duration > 0) {
          MediaSessionManager.setPositionState({
            duration: duration,
            position: currentTime,
            playbackRate: speed
          });
        }
      }, [currentTime, duration, speed, podcastAudio, videoId]);

      // Resume YouTube playback after car mode changes if it was playing
      useEffect(() => {
        if (videoId && playerRef.current && wasPlayingRef.current) {
          // Small delay to let the DOM settle after car mode toggle
          const timer = setTimeout(() => {
            playerRef.current?.playVideo();
          }, 150);
          return () => clearTimeout(timer);
        }
      }, [carMode, videoId]);

      const extractVideoId = (url) => {
        const match = url.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/);
        return match ? match[1] : null;
      };

      // Detect URL type based on the actual URL
      const detectUrlType = (url) => {
        const lowerUrl = url.toLowerCase();
        // YouTube URLs
        if (lowerUrl.includes('youtube.com') || lowerUrl.includes('youtu.be')) {
          return 'youtube';
        }
        // Spotify URLs (will be converted to RSS)
        if (lowerUrl.includes('open.spotify.com') || lowerUrl.includes('spotify.com')) {
          return 'spotify';
        }
        // Direct audio file URLs
        if (lowerUrl.match(/\.(mp3|m4a|ogg|wav|aac)(\?|$)/)) {
          return 'audio';
        }
        // RSS feed URLs - match common patterns and podcast hosting domains
        if (lowerUrl.includes('.xml') || lowerUrl.includes('/rss') || lowerUrl.includes('/feed') ||
            lowerUrl.match(/\b(feeds?|rss)\./i) || lowerUrl.includes('anchor.fm') ||
            lowerUrl.includes('podcastfeeds.') || lowerUrl.includes('megaphone.fm') ||
            lowerUrl.includes('omnycontent.com') || lowerUrl.includes('podbean.com') ||
            lowerUrl.includes('acast.com') || lowerUrl.includes('buzzsprout.com') ||
            lowerUrl.includes('simplecast.com') || lowerUrl.includes('libsyn.com') ||
            lowerUrl.includes('spreaker.com') || lowerUrl.includes('podomatic.com') ||
            lowerUrl.includes('art19.com') || lowerUrl.includes('transistor.fm') ||
            lowerUrl.includes('captivate.fm') || lowerUrl.includes('redcircle.com') ||
            lowerUrl.includes('audioboom.com') || lowerUrl.includes('pcdn.co') ||
            lowerUrl.includes('podcasts.apple.com') || lowerUrl.includes('podtrac.com')) {
          return 'rss';
        }
        return null;
      };

      // Fetch Spotify metadata using oEmbed API
      const fetchSpotifyMetadata = async (spotifyUrl) => {
        try {
          const oembedUrl = `https://open.spotify.com/oembed?url=${encodeURIComponent(spotifyUrl)}`;
          const response = await fetch(oembedUrl);
          if (!response.ok) throw new Error('Failed to fetch Spotify metadata');
          const data = await response.json();
          return {
            title: data.title,
            showName: data.provider_name === 'Spotify' ? data.title.split(' - ')[0] : data.provider_name,
            thumbnailUrl: data.thumbnail_url
          };
        } catch (error) {
          console.error('Spotify oEmbed error:', error);
          return null;
        }
      };

      // Search for RSS feed using podcast name
      const searchForRSSFeed = async (showName, episodeTitle) => {
        try {
          // Use iTunes Search API to find podcast RSS feed
          const searchQuery = encodeURIComponent(showName);
          const response = await fetch(`https://itunes.apple.com/search?term=${searchQuery}&media=podcast&limit=5`);
          if (!response.ok) throw new Error('iTunes search failed');
          const data = await response.json();

          if (data.results && data.results.length > 0) {
            // Return the first matching podcast's feed URL
            return {
              feedUrl: data.results[0].feedUrl,
              podcastName: data.results[0].collectionName,
              artworkUrl: data.results[0].artworkUrl600 || data.results[0].artworkUrl100
            };
          }
          return null;
        } catch (error) {
          console.error('RSS search error:', error);
          return null;
        }
      };

      // Fetch cover art for a podcast using iTunes search
      const fetchCoverArt = async () => {
        if (!podcastAudio) return;

        setIsLoadingArtwork(true);
        const searchTerm = podcastAudio.showName || podcastAudio.title;

        try {
          const searchQuery = encodeURIComponent(searchTerm);
          const response = await fetch(`https://itunes.apple.com/search?term=${searchQuery}&media=podcast&limit=5`);
          if (!response.ok) throw new Error('iTunes search failed');
          const data = await response.json();

          if (data.results && data.results.length > 0) {
            const artworkUrl = data.results[0].artworkUrl600 || data.results[0].artworkUrl100;
            if (artworkUrl) {
              // Update local state
              setPodcastAudio(prev => ({ ...prev, artworkUrl }));
              setArtworkFailed(false);
              // Update stored source
              if (currentSource?.id) {
                updateSource(currentSource.id, { artworkUrl });
              }
              showToast('Cover art loaded');
            } else {
              showToast('No cover art found');
              setArtworkFailed(true);
            }
          } else {
            showToast('Could not find podcast artwork');
            setArtworkFailed(true);
          }
        } catch (error) {
          console.error('Artwork fetch error:', error);
          showToast('Failed to load cover art');
          setArtworkFailed(true);
        }

        setIsLoadingArtwork(false);
      };

      // Parse RSS feed and find episode
      const parseRSSAndFindEpisode = async (feedUrl, episodeTitle) => {
        try {
          // Use a CORS proxy for RSS feeds
          const corsProxy = 'https://api.allorigins.win/raw?url=';
          const response = await fetch(corsProxy + encodeURIComponent(feedUrl));
          if (!response.ok) throw new Error('Failed to fetch RSS feed');
          const xmlText = await response.text();

          const parser = new DOMParser();
          const xml = parser.parseFromString(xmlText, 'text/xml');
          const items = xml.querySelectorAll('item');

          // Extract channel info
          const channel = xml.querySelector('channel');
          const channelTitle = channel?.querySelector(':scope > title')?.textContent || '';
          const itunesImage = channel?.getElementsByTagName('itunes:image')[0];
          const channelArtwork = itunesImage?.getAttribute('href') ||
                                 channel?.querySelector('image url')?.textContent || '';

          // Try to find matching episode by title
          let bestMatch = null;
          let bestScore = 0;

          const normalizeTitle = (t) => t.toLowerCase().replace(/[^a-z0-9]/g, '');
          const targetTitle = normalizeTitle(episodeTitle);

          items.forEach((item, index) => {
            const title = item.querySelector('title')?.textContent || '';
            const enclosure = item.querySelector('enclosure');
            const audioUrl = enclosure?.getAttribute('url');

            if (audioUrl) {
              // Score based on title similarity
              const itemTitle = normalizeTitle(title);
              let score = 0;

              // Check for substring match
              if (itemTitle.includes(targetTitle) || targetTitle.includes(itemTitle)) {
                score = 100;
              } else {
                // Count matching words
                const targetWords = targetTitle.split(/\s+/);
                const itemWords = itemTitle.split(/\s+/);
                targetWords.forEach(word => {
                  if (word.length > 3 && itemTitle.includes(word)) score += 10;
                });
              }

              // Prefer first match if scores are equal (usually most recent)
              if (score > bestScore || (score === bestScore && !bestMatch)) {
                bestScore = score;

                const description = item.querySelector('description')?.textContent || '';

                bestMatch = {
                  title: title,
                  audioUrl: audioUrl,
                  description: description,
                  artworkUrl: channelArtwork,
                  channelTitle: channelTitle,
                  pubDate: item.querySelector('pubDate')?.textContent || '',
                  link: item.querySelector('link')?.textContent || ''
                };
              }
            }
          });

          // If no good match, return first episode with audio
          if (!bestMatch && items.length > 0) {
            const firstItem = items[0];
            const enclosure = firstItem.querySelector('enclosure');
            if (enclosure?.getAttribute('url')) {
              const description = firstItem.querySelector('description')?.textContent || '';

              bestMatch = {
                title: firstItem.querySelector('title')?.textContent || 'Unknown Episode',
                audioUrl: enclosure.getAttribute('url'),
                description: description,
                artworkUrl: channelArtwork,
                channelTitle: channelTitle,
                pubDate: firstItem.querySelector('pubDate')?.textContent || '',
                link: firstItem.querySelector('link')?.textContent || ''
              };
            }
          }

          return bestMatch;
        } catch (error) {
          console.error('RSS parse error:', error);
          return null;
        }
      };

      // Load podcast from Spotify URL
      const loadPodcastFromSpotify = async () => {
        setIsLoadingPodcast(true);
        showToast('Searching for podcast feed...');

        try {
          // Step 1: Get Spotify metadata
          const metadata = await fetchSpotifyMetadata(url);
          if (!metadata) {
            showToast('Could not fetch Spotify metadata');
            setIsLoadingPodcast(false);
            return;
          }

          showToast(`Found: ${metadata.title}`);

          // Step 2: Search for RSS feed
          const rssInfo = await searchForRSSFeed(metadata.showName, metadata.title);
          if (!rssInfo) {
            showToast('Could not find RSS feed for this podcast');
            setIsLoadingPodcast(false);
            return;
          }

          showToast(`Found feed: ${rssInfo.podcastName}`);

          // Step 3: Parse RSS and find episode
          const episode = await parseRSSAndFindEpisode(rssInfo.feedUrl, metadata.title);
          if (!episode) {
            showToast('Could not find episode in RSS feed');
            setIsLoadingPodcast(false);
            return;
          }

          // Success! Load the audio
          setVideoId(null);
          setArtworkFailed(false);
          setPodcastAudio({
            audioUrl: episode.audioUrl,
            title: episode.title,
            showName: rssInfo.podcastName,
            artworkUrl: rssInfo.artworkUrl,
            link: episode.link || url
          });

          addSource({
            type: 'podcast',
            title: episode.title,
            url: url,
            audioUrl: episode.audioUrl,
            showName: rssInfo.podcastName,
            artworkUrl: rssInfo.artworkUrl,
            link: episode.link || url
          });

          setUrl(''); // Clear URL after successful load
          showToast('Podcast loaded!');
        } catch (error) {
          console.error('Podcast loading error:', error);
          showToast('Failed to load podcast');
        }

        setIsLoadingPodcast(false);
      };

      // Load direct RSS feed
      const loadRSSFeed = async (feedUrl) => {
        setIsLoadingPodcast(true);
        showToast('Loading RSS feed...');

        try {
          const episode = await parseRSSAndFindEpisode(feedUrl, '');
          if (!episode) {
            showToast('Could not find episodes in RSS feed');
            setIsLoadingPodcast(false);
            return;
          }

          const showName = episode.channelTitle || 'Podcast';

          setVideoId(null);
          setArtworkFailed(false);
          setPodcastAudio({
            audioUrl: episode.audioUrl,
            title: episode.title,
            showName: showName,
            artworkUrl: episode.artworkUrl || '',
            link: episode.link || feedUrl
          });

          addSource({
            type: 'podcast',
            title: episode.title,
            url: feedUrl,
            audioUrl: episode.audioUrl,
            showName: showName,
            artworkUrl: episode.artworkUrl || '',
            link: episode.link || feedUrl
          });

          setUrl(''); // Clear URL after successful load
          showToast('Podcast loaded!');
        } catch (error) {
          showToast('Failed to load RSS feed');
        }

        setIsLoadingPodcast(false);
      };

      const loadMedia = async () => {
        const urlType = detectUrlType(url);

        if (urlType === 'youtube') {
          const id = extractVideoId(url);
          if (!id) {
            showToast('Invalid YouTube URL');
            return;
          }

          setVideoId(id);
          setPodcastAudio(null);

          // Fetch YouTube title and channel via oEmbed API
          let videoTitle = 'YouTube Video';
          let channelName = '';
          try {
            const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
            const response = await fetch(oembedUrl);
            if (response.ok) {
              const data = await response.json();
              videoTitle = data.title || 'YouTube Video';
              channelName = data.author_name || '';
            }
          } catch (err) {
            console.log('Could not fetch YouTube metadata:', err);
          }

          addSource({
            type: 'youtube',
            title: videoTitle,
            url: url,
            videoId: id,
            channelName: channelName
          });

          setUrl(''); // Clear URL after successful load

          // Initialize player after state update
          setTimeout(() => {
            if (window.YT && window.YT.Player) {
              initPlayer(id);
            } else {
              window.onYouTubeIframeAPIReady = () => initPlayer(id);
            }
          }, 100);
        } else if (urlType === 'spotify') {
          loadPodcastFromSpotify();
        } else if (urlType === 'rss') {
          loadRSSFeed(url);
        } else if (urlType === 'audio') {
          // Direct audio URL
          setVideoId(null);
          setArtworkFailed(false);
          setPodcastAudio({
            audioUrl: url,
            title: 'Audio',
            showName: ''
          });
          addSource({
            type: 'podcast',
            title: 'Audio',
            url: url,
            audioUrl: url
          });
          setUrl(''); // Clear URL after successful load
          showToast('Audio loaded');
        } else {
          // Unknown URL type - try loading as RSS feed before giving up
          try {
            const corsProxy = 'https://api.allorigins.win/raw?url=';
            const response = await fetch(corsProxy + encodeURIComponent(url));
            if (response.ok) {
              const text = await response.text();
              // Check if response looks like XML/RSS content
              if (text.trim().startsWith('<?xml') || text.trim().startsWith('<rss') || text.includes('<channel>') || text.includes('<feed')) {
                loadRSSFeed(url);
                return;
              }
            }
          } catch (e) {
            // Fetch failed, fall through to error
          }
          showToast('Please enter a YouTube, Spotify, or RSS feed URL');
        }
      };

      // Text note functions
      const openTextNote = () => {
        // Store playback state and pause if playing
        if (isPlaying) {
          wasPlayingRef.current = true;
          if (audioPlayerRef.current) audioPlayerRef.current.pause();
          if (playerRef.current) playerRef.current.pauseVideo();
          setIsPlaying(false);
        } else {
          wasPlayingRef.current = false;
        }
        setShowTextNote(true);
      };

      const saveTextNote = () => {
        if (textNote.trim() && currentSource) {
          addNote({
            sourceId: currentSource.id,
            timestamp: currentTime,
            text: textNote.trim(),
            type: 'text'
          });
          showToast('Note saved');
        }
        setTextNote('');
        setShowTextNote(false);
        // Resume playback if it was playing
        if (wasPlayingRef.current) {
          if (audioPlayerRef.current) audioPlayerRef.current.play();
          if (playerRef.current) playerRef.current.playVideo();
        }
      };

      const cancelTextNote = () => {
        setTextNote('');
        setShowTextNote(false);
        // Resume playback if it was playing
        if (wasPlayingRef.current) {
          if (audioPlayerRef.current) audioPlayerRef.current.play();
          if (playerRef.current) playerRef.current.playVideo();
        }
      };

      // Wake Lock helpers to keep screen on during playback
      const requestWakeLock = async () => {
        try {
          if ('wakeLock' in navigator) {
            // Release old wake lock if it exists
            if (wakeLockRef.current) {
              try {
                await wakeLockRef.current.release();
              } catch (e) {
                // Ignore errors from releasing
              }
            }

            // Always request fresh wake lock (handles screen on/off cycles)
            wakeLockRef.current = await navigator.wakeLock.request('screen');
            console.log('Wake Lock activated');

            // Listen for release event to clear the ref
            wakeLockRef.current.addEventListener('release', () => {
              console.log('Wake Lock was released');
              wakeLockRef.current = null;
            });
          }
        } catch (err) {
          console.log('Wake Lock not supported or failed:', err);
          wakeLockRef.current = null;
        }
      };

      const releaseWakeLock = async () => {
        try {
          if (wakeLockRef.current) {
            await wakeLockRef.current.release();
            wakeLockRef.current = null;
            console.log('Wake Lock released');
          }
        } catch (err) {
          console.log('Wake Lock release failed:', err);
        }
      };

      const initPlayer = (id) => {
        if (playerRef.current && playerRef.current.destroy) {
          playerRef.current.destroy();
        }

        playerRef.current = new window.YT.Player('youtube-player', {
          videoId: id,
          playerVars: {
            autoplay: 0,
            controls: 1,
            modestbranding: 1,
            rel: 0
          },
          events: {
            onReady: (event) => {
              const dur = event.target.getDuration();
              setDuration(dur);
              // Update source with duration for Library display
              if (currentSource?.id && dur && isFinite(dur)) {
                updateSource(currentSource.id, { duration: dur });
              }
            },
            onStateChange: (event) => {
              setIsPlaying(event.data === window.YT.PlayerState.PLAYING);

              if (event.data === window.YT.PlayerState.PLAYING) {
                requestWakeLock(); // Keep screen on while playing
                intervalRef.current = setInterval(() => {
                  setCurrentTime(playerRef.current.getCurrentTime());
                }, 500);
              } else {
                releaseWakeLock(); // Release when paused/stopped
                clearInterval(intervalRef.current);
              }

              // Auto-mark as read when video ends
              if (event.data === window.YT.PlayerState.ENDED) {
                if (currentSource?.id && !currentSource.isRead) {
                  updateSource(currentSource.id, { isRead: true });
                }
              }
            }
          }
        });
      };

      const togglePlayback = () => {
        if (!playerRef.current) return;

        if (isPlaying) {
          playerRef.current.pauseVideo();
        } else {
          playerRef.current.playVideo();
        }
      };

      const skipTime = (seconds) => {
        if (!playerRef.current) return;
        const wasPlaying = isPlaying;
        const newTime = Math.max(0, Math.min(duration, currentTime + seconds));
        playerRef.current.seekTo(newTime, true);
        setCurrentTime(newTime);
        // Resume playback if it was playing before seek
        if (wasPlaying) {
          setTimeout(() => playerRef.current?.playVideo(), 100);
        }
      };

      const stopRecording = () => {
        if (mediaRecorderRef.current) {
          try {
            playSound('stop');
            mediaRecorderRef.current.stop();
          } catch (err) {
            console.log('Error stopping recognition:', err);
          }
          mediaRecorderRef.current = null;
        }
        if (streamRef.current) {
          streamRef.current.getTracks().forEach(track => track.stop());
          streamRef.current = null;
        }
      };

      const handleVoiceButtonClick = () => {
        if (isRecording) {
          stopRecording();
        } else if (isTranscribing || whisperLoading) {
          playSound('error');
          showToast(whisperLoading ? 'Loading speech model...' : 'Still processing...');
        } else if (isStartingRecordingRef.current) {
          playSound('error');
          showToast('Please wait, starting recording...');
        } else {
          startRecording();
        }
      };

      // Load Whisper model for fallback
      const loadWhisperModel = async () => {
        if (window.WhisperASR?.isReady) {
          setUseWhisperFallback(true);
          return true;
        }
        if (whisperLoading) return false;

        setWhisperLoading(true);
        showToast('Loading offline speech model (40MB)...');

        const success = await window.WhisperASR?.loadModel((progress) => {
          setWhisperProgress(progress);
        });

        setWhisperLoading(false);
        if (success) {
          setUseWhisperFallback(true);
          showToast('Offline speech model ready!');
          return true;
        } else {
          showToast('Failed to load offline model');
          return false;
        }
      };

      // Start recording using Whisper (MediaRecorder-based) with silence detection
      const startWhisperRecording = async (wasPlaying, recordingTime) => {
        try {
          const audioConstraints = {
            audio: {
              echoCancellation: { ideal: true },
              noiseSuppression: { ideal: true },
              autoGainControl: { ideal: true },
              channelCount: { ideal: 1 },
              sampleRate: { ideal: 16000 }
            }
          };
          const stream = await navigator.mediaDevices.getUserMedia(audioConstraints);
          streamRef.current = stream;

          // Set up silence detection using Web Audio API
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          audioContextRef.current = audioContext;
          const analyser = audioContext.createAnalyser();
          analyzerRef.current = analyser;
          analyser.fftSize = 512;
          analyser.smoothingTimeConstant = 0.1;

          const source = audioContext.createMediaStreamSource(stream);
          source.connect(analyser);

          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          let silenceStart = null;
          let hasDetectedSpeech = false;
          const SILENCE_THRESHOLD = 15; // Audio level below this is considered silence
          const SILENCE_DURATION = 1000; // Stop after 1 second of silence
          const MAX_RECORDING_TIME = 60000; // Maximum 60 seconds
          const recordingStartTime = Date.now();

          const mimeType = window.WhisperASR?.getSupportedMimeType() || '';
          const mediaRecorder = mimeType
            ? new MediaRecorder(stream, { mimeType })
            : new MediaRecorder(stream);
          mediaRecorderRef.current = mediaRecorder;

          const audioChunks = [];

          // Silence detection loop
          const checkSilence = () => {
            if (!mediaRecorderRef.current || mediaRecorderRef.current.state !== 'recording') {
              return;
            }

            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

            // Check for max recording time
            if (Date.now() - recordingStartTime > MAX_RECORDING_TIME) {
              console.log('Max recording time reached, stopping');
              mediaRecorderRef.current.stop();
              return;
            }

            if (average > SILENCE_THRESHOLD) {
              // Sound detected
              hasDetectedSpeech = true;
              silenceStart = null;
            } else if (hasDetectedSpeech) {
              // Silence after speech
              if (!silenceStart) {
                silenceStart = Date.now();
              } else if (Date.now() - silenceStart > SILENCE_DURATION) {
                console.log('Silence detected for 2 seconds, stopping recording');
                mediaRecorderRef.current.stop();
                return;
              }
            }

            silenceTimeoutRef.current = requestAnimationFrame(checkSilence);
          };

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunks.push(event.data);
            }
          };

          mediaRecorder.onerror = (event) => {
            console.error('MediaRecorder error:', event.error);
            if (silenceTimeoutRef.current) {
              cancelAnimationFrame(silenceTimeoutRef.current);
            }
            if (audioContextRef.current) {
              audioContextRef.current.close().catch(() => {});
            }
            showToast('Recording error. Try again.');
            stream.getTracks().forEach(track => track.stop());
            setIsRecording(false);
            isStartingRecordingRef.current = false;
          };

          mediaRecorder.onstop = async () => {
            // Clean up silence detection
            if (silenceTimeoutRef.current) {
              cancelAnimationFrame(silenceTimeoutRef.current);
            }
            if (audioContextRef.current) {
              audioContextRef.current.close().catch(() => {});
              audioContextRef.current = null;
            }

            stream.getTracks().forEach(track => track.stop());
            streamRef.current = null;

            if (audioChunks.length === 0) {
              playSound('error');
              showToast('No audio captured. Try again.');
              setIsRecording(false);
              return;
            }

            const audioBlob = new Blob(audioChunks, { type: mimeType || 'audio/webm' });

            if (audioBlob.size < 500) {
              playSound('error');
              showToast('Recording too short. Try again.');
              setIsRecording(false);
              return;
            }

            setIsRecording(false);
            setIsTranscribing(true);

            try {
              const transcript = await window.WhisperASR.transcribe(audioBlob);
              if (transcript && transcript.trim()) {
                addNote({
                  sourceId: currentSource?.id,
                  text: transcript.trim(),
                  timestamp: recordingTime,
                  type: 'voice'
                });
                playSound('success');
                showToast('Note saved!');
              } else {
                playSound('error');
                showToast('No speech detected - try speaking louder');
              }
            } catch (error) {
              console.error('Transcription failed:', error);
              playSound('error');
              showToast('Transcription failed. Try again.');
            }
            setIsTranscribing(false);

            // Resume playback if it was playing before recording (use passed parameter, not ref)
            if (wasPlaying) {
              if (audioPlayerRef.current) {
                audioPlayerRef.current.play();
                requestWakeLock();
              }
              if (playerRef.current) {
                playerRef.current.playVideo();
              }
            }
          };

          mediaRecorder.start(100);
          setIsRecording(true);
          isStartingRecordingRef.current = false;
          playSound('start');
          showToast('Listening (offline mode)...');

          // Start silence detection
          checkSilence();
        } catch (error) {
          console.error('Failed to start Whisper recording:', error);
          playSound('error');
          showToast('Failed to access microphone');
          setIsRecording(false);
          isStartingRecordingRef.current = false;
        }
      };

      const startRecording = async () => {
        console.log('=== startRecording called (MediaView) ===');
        console.log('speechReady:', speechReady, 'useWhisperFallback:', useWhisperFallback);

        if (!speechReady) {
          playSound('error');
          showToast('Speech recognition not available. Use text notes.');
          return;
        }

        if (isStartingRecordingRef.current) {
          return;
        }
        isStartingRecordingRef.current = true;

        stopRecording();

        // Capture playing state in local variable BEFORE pausing (closures will preserve this)
        const wasPlaying = isPlaying;
        const recordingTime = currentTime;

        if (isPlaying && playerRef.current) {
          playerRef.current.pauseVideo();
        }
        if (isPlaying && audioPlayerRef.current) {
          audioPlayerRef.current.pause();
        }

        // Use Whisper if fallback is enabled or Web Speech has had network errors
        if (useWhisperFallback || window.WebSpeechAPI?.hasNetworkError) {
          if (!window.WhisperASR?.isReady) {
            const loaded = await loadWhisperModel();
            if (!loaded) {
              isStartingRecordingRef.current = false;
              return;
            }
          }
          await startWhisperRecording(wasPlaying, recordingTime);
          return;
        }

        // Try Web Speech API (primary)
        try {
          const recognition = window.WebSpeechAPI.createRecognition({
            continuous: false,
            interimResults: true,
            lang: 'en-US'
          });

          let finalTranscript = '';
          let hasResult = false;
          let hadError = false;

          recognition.onstart = () => {
            console.log('Web Speech recognition started (MediaView)');
            setIsRecording(true);
            isStartingRecordingRef.current = false;
            playSound('start');
            showToast('Listening...');
          };

          recognition.onresult = (event) => {
            hasResult = true;
            let interimTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
              const transcript = event.results[i][0].transcript;
              if (event.results[i].isFinal) {
                finalTranscript += transcript;
              } else {
                interimTranscript += transcript;
              }
            }
            console.log('Interim:', interimTranscript, 'Final:', finalTranscript);
          };

          recognition.onend = () => {
            console.log('Web Speech recognition ended (MediaView)');
            setIsRecording(false);
            isStartingRecordingRef.current = false;

            if (hadError) {
              console.log('Skipping onend message - error already handled');
            } else if (finalTranscript.trim()) {
              addNote({
                sourceId: currentSource?.id,
                text: finalTranscript.trim(),
                timestamp: recordingTime,
                type: 'voice'
              });
              playSound('success');
              showToast('Note saved!');
            } else if (hasResult) {
              playSound('error');
              showToast('No speech detected - try again');
            } else {
              playSound('error');
              showToast('No speech detected - try speaking louder');
            }

            // Resume playback if it was playing before recording (use local variable from closure)
            if (wasPlaying) {
              if (audioPlayerRef.current) {
                audioPlayerRef.current.play();
                requestWakeLock();
              }
              if (playerRef.current) {
                playerRef.current.playVideo();
              }
            }
          };

          recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            hadError = true;
            setIsRecording(false);
            isStartingRecordingRef.current = false;

            if (event.error === 'network') {
              window.WebSpeechAPI.markNetworkError();
              playSound('error');
              showToast('Network error - switching to offline mode...');
              loadWhisperModel().then(success => {
                if (success) {
                  showToast('Offline mode ready! Try recording again.');
                }
              });
            } else if (event.error === 'not-allowed' || event.error === 'permission-denied') {
              playSound('error');
              showToast('Microphone access denied');
            } else if (event.error === 'no-speech') {
              playSound('error');
              showToast('No speech detected - try again');
            } else if (event.error === 'aborted') {
              playSound('error');
              showToast('Speech recognition interrupted. Try again.');
            } else if (event.error === 'audio-capture') {
              playSound('error');
              showToast('No microphone found. Check your audio settings.');
            } else {
              playSound('error');
              showToast(`Speech recognition error: ${event.error}`);
            }

            // Resume playback even on error (use local variable from closure)
            if (wasPlaying) {
              if (audioPlayerRef.current) {
                audioPlayerRef.current.play();
                requestWakeLock();
              }
              if (playerRef.current) {
                playerRef.current.playVideo();
              }
            }
          };

          // Store recognition instance for stopRecording
          mediaRecorderRef.current = recognition;

          console.log('Starting speech recognition...');
          recognition.start();
          console.log('Speech recognition start() called');
        } catch (error) {
          console.error('Failed to start speech recognition:', error);
          playSound('error');
          showToast('Speech recognition failed to start');
          setIsRecording(false);
          isStartingRecordingRef.current = false;
        }
      };

      const progress = duration ? (currentTime / duration) * 100 : 0;

      return (
        <div style={{ display: 'flex', flexDirection: 'column', flex: 1, minHeight: 0, overflow: 'hidden' }}>
          <div className="input-section" style={{ display: carMode ? 'none' : 'block' }}>
            <div className="input-group">
              <input
                type="text"
                className="url-input"
                placeholder="Paste YouTube, podcast, or RSS feed link..."
                value={url}
                onChange={(e) => setUrl(e.target.value)}
              />
              <button className="btn btn-primary" onClick={loadMedia} disabled={isLoadingPodcast}>
                {isLoadingPodcast ? 'Loading...' : <><Icons.Link /> Load</>}
              </button>
            </div>
          </div>

          {videoId ? (
            <div className="media-container">
              {currentSource && (
                <div className="reader-header">
                  <div className="source-info" style={{ flex: 1 }}>
                    <div style={{ display: 'flex', alignItems: 'flex-start', gap: '1rem' }}>
                      <EditableTitle
                        title={currentSource.title || 'YouTube Video'}
                        onSave={(newTitle) => updateSource(currentSource.id, { title: newTitle })}
                      />
                      <div
                        className={`read-status clickable ${currentSource.isRead ? 'checked' : ''}`}
                        onClick={() => updateSource(currentSource.id, { isRead: !currentSource.isRead })}
                        title={currentSource.isRead ? 'Mark as unread' : 'Mark as read'}
                        style={{ marginTop: '0.25rem' }}
                      >
                        {currentSource.isRead && <Icons.Check />}
                      </div>
                    </div>
                    <div className="source-meta">
                      <span className="library-item-type youtube">YouTube</span>
                      {currentSource.channelName && <span className="source-name">{currentSource.channelName}</span>}
                      {duration > 0 && <span>{formatTime(duration)}</span>}
                      {currentSource.url && <a href={currentSource.url} target="_blank" rel="noopener noreferrer"><Icons.Link /></a>}
                    </div>
                  </div>
                </div>
              )}
              <div className="youtube-container" style={carMode ? { position: 'absolute', width: '1px', height: '1px', opacity: 0, pointerEvents: 'none' } : {}}>
                <div id="youtube-player"></div>
              </div>

              {showTextNote && (
                <div className="text-note-container">
                  <input
                    type="text"
                    className="url-input text-note-input"
                    placeholder="Type your note..."
                    value={textNote}
                    onChange={(e) => setTextNote(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && saveTextNote()}
                    autoFocus
                  />
                  <div className="text-note-buttons">
                    <button className="btn btn-primary" onClick={saveTextNote}>Save</button>
                    <button className="btn btn-secondary" onClick={cancelTextNote}>Cancel</button>
                  </div>
                </div>
              )}

              <div className={`playback-bar ${carMode ? 'car-mode' : ''}`}>
                <div className="playback-controls">
                  <div className="transport-buttons">
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={() => skipTime(-15)}
                      title="Back 15 seconds"
                    >
                      <Icons.Rewind />
                      <span style={{ fontSize: '0.65rem', marginLeft: '2px' }}>15</span>
                    </button>
                    <button className={`play-btn ${carMode ? 'car-mode' : ''}`} onClick={togglePlayback}>
                      {isPlaying ? <Icons.Pause /> : <Icons.Play />}
                    </button>
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={() => skipTime(15)}
                      title="Forward 15 seconds"
                    >
                      <span style={{ fontSize: '0.65rem', marginRight: '2px' }}>15</span>
                      <Icons.FastForward />
                    </button>
                  </div>

                  <div className={`progress-speed-group ${carMode ? 'car-mode' : ''}`}>
                    <div className="progress-container">
                      <div className={`progress-bar ${carMode ? 'car-mode' : ''}`}>
                        <div className="progress-fill" style={{ width: `${progress}%` }} />
                      </div>
                      <div className="progress-text">
                        <span>{formatTime(currentTime)}</span>
                        <span>{formatTime(duration)}</span>
                      </div>
                    </div>

                    <div className={`speed-control ${carMode ? 'car-mode' : ''}`}>
                      <label>Speed</label>
                      <select value={speed} onChange={(e) => setSpeed(parseFloat(e.target.value))}>
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1">1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                      </select>
                    </div>
                  </div>
                </div>

                <div className="note-controls">
                  <button
                    className={`note-btn ${isProcessing ? 'processing' : ''} ${carMode ? 'car-mode' : ''}`}
                    onClick={handleVoiceButtonClick}
                    disabled={!speechReady || whisperLoading}
                    title={!speechReady ? 'Speech recognition not supported' : (useWhisperFallback ? 'Using offline mode' : '')}
                  >
                    {isRecording ? ' Stop' :
                     whisperLoading ? `Loading ${whisperProgress}%` :
                     isTranscribing ? 'Processing...' :
                     <><Icons.Mic /> Voice{useWhisperFallback ? ' (offline)' : ''}</>}
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    onClick={openTextNote}
                  >
                    <Icons.Keyboard /> Type
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    disabled={true}
                    title="Search not available for YouTube"
                    style={{ opacity: 0.5 }}
                  >
                    <Icons.Search /> Search
                  </button>
                  {isMobileDevice && (
                    <button
                      className={`note-btn ${carMode ? 'car-mode active' : ''}`}
                      onClick={() => setCarMode(!carMode)}
                      title="Car Mode"
                    >
                      <Icons.Car />
                    </button>
                  )}
                </div>
              </div>
            </div>
          ) : podcastAudio ? (
            <div className="reader-container">
              <div className="reader-header">
                <div className="source-info" style={{ flex: 1 }}>
                  <div style={{ display: 'flex', alignItems: 'flex-start', gap: '1rem' }}>
                    <EditableTitle
                      title={podcastAudio.title}
                      onSave={(newTitle) => {
                        if (currentSource) {
                          updateSource(currentSource.id, { title: newTitle });
                        }
                        setPodcastAudio(prev => ({ ...prev, title: newTitle }));
                      }}
                    />
                    {currentSource && (
                      <div
                        className={`read-status clickable ${currentSource.isRead ? 'checked' : ''}`}
                        onClick={() => updateSource(currentSource.id, { isRead: !currentSource.isRead })}
                        title={currentSource.isRead ? 'Mark as unread' : 'Mark as read'}
                        style={{ marginTop: '0.25rem' }}
                      >
                        {currentSource.isRead && <Icons.Check />}
                      </div>
                    )}
                  </div>
                  <div className="source-meta">
                    <span className="library-item-type podcast">Podcast</span>
                    {podcastAudio.showName && <span className="source-name">{podcastAudio.showName}</span>}
                    <span>{formatTime(duration)}</span>
                    {podcastAudio.link && <a href={podcastAudio.link} target="_blank" rel="noopener noreferrer"><Icons.Link /></a>}
                  </div>
                </div>
              </div>

              {/* Audio element placed early so it loads before artwork */}
              <audio
                ref={audioPlayerRef}
                src={podcastAudio.audioUrl}
                onTimeUpdate={(e) => setCurrentTime(e.target.currentTime)}
                onDurationChange={(e) => {
                  const dur = e.target.duration;
                  setDuration(dur);
                  // Update source with duration for Library display
                  if (currentSource?.id && dur && isFinite(dur)) {
                    updateSource(currentSource.id, { duration: dur });
                  }
                }}
                onPlay={() => { setIsPlaying(true); requestWakeLock(); }}
                onPause={() => { setIsPlaying(false); releaseWakeLock(); }}
                onEnded={() => {
                  releaseWakeLock();
                  // Auto-mark as read when podcast ends
                  if (currentSource?.id && !currentSource.isRead) {
                    updateSource(currentSource.id, { isRead: true });
                  }
                }}
                onError={(e) => {
                  console.error('Audio load error:', e.target.error);
                  showToast('Failed to load audio - the URL may be blocked or unavailable');
                }}
                style={{ display: 'none' }}
              />

              {!carMode && (
                <div style={{ display: 'flex', justifyContent: 'center', padding: '1rem' }}>
                  {(!podcastAudio.artworkUrl || artworkFailed) ? (
                    <button
                      onClick={fetchCoverArt}
                      disabled={isLoadingArtwork}
                      style={{
                        width: '200px',
                        height: '200px',
                        borderRadius: '12px',
                        border: '2px dashed var(--border)',
                        background: 'var(--bg-secondary)',
                        cursor: isLoadingArtwork ? 'wait' : 'pointer',
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: '0.5rem',
                        color: 'var(--text-muted)',
                        fontSize: '0.875rem',
                        opacity: isLoadingArtwork ? 0.7 : 1
                      }}
                    >
                      <Icons.Image />
                      <span>{isLoadingArtwork ? 'Loading...' : 'Load Cover Art'}</span>
                    </button>
                  ) : (
                    <img
                      key={podcastAudio.artworkUrl}
                      src={podcastAudio.artworkUrl}
                      alt="Podcast artwork"
                      loading="lazy"
                      onError={() => setArtworkFailed(true)}
                      style={{ width: '200px', height: '200px', borderRadius: '12px', boxShadow: '0 4px 12px rgba(0,0,0,0.15)' }}
                    />
                  )}
                </div>
              )}

              {/* Spacer to allow flex shrinking when text note appears - hidden in car mode */}
              <div style={{ flex: 1, minHeight: 0, display: carMode ? 'none' : 'block' }} />

              {showTextNote && (
                <div className="text-note-container">
                  <input
                    type="text"
                    className="url-input text-note-input"
                    placeholder="Type your note..."
                    value={textNote}
                    onChange={(e) => setTextNote(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && saveTextNote()}
                    autoFocus
                  />
                  <div className="text-note-buttons">
                    <button className="btn btn-primary" onClick={saveTextNote}>Save</button>
                    <button className="btn btn-secondary" onClick={cancelTextNote}>Cancel</button>
                  </div>
                </div>
              )}

              <div className={`playback-bar ${carMode ? 'car-mode' : ''}`}>
                <div className="playback-controls">
                  <div className="transport-buttons">
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={() => { if (audioPlayerRef.current) audioPlayerRef.current.currentTime -= 15; }}
                      title="Back 15 seconds"
                    >
                      <Icons.Rewind />
                      <span style={{ fontSize: '0.65rem', marginLeft: '2px' }}>15</span>
                    </button>
                    <button className={`play-btn ${carMode ? 'car-mode' : ''}`} onClick={() => {
                      if (audioPlayerRef.current) {
                        if (isPlaying) {
                          audioPlayerRef.current.pause();
                        } else {
                          audioPlayerRef.current.play();
                        }
                      }
                    }}>
                      {isPlaying ? <Icons.Pause /> : <Icons.Play />}
                    </button>
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={() => { if (audioPlayerRef.current) audioPlayerRef.current.currentTime += 15; }}
                      title="Forward 15 seconds"
                    >
                      <span style={{ fontSize: '0.65rem', marginRight: '2px' }}>15</span>
                      <Icons.FastForward />
                    </button>
                  </div>

                  <div className={`progress-speed-group ${carMode ? 'car-mode' : ''}`}>
                    <div className="progress-container">
                      <div className={`progress-bar ${carMode ? 'car-mode' : ''}`} onClick={(e) => {
                        if (audioPlayerRef.current && duration) {
                          const rect = e.currentTarget.getBoundingClientRect();
                          const percent = (e.clientX - rect.left) / rect.width;
                          audioPlayerRef.current.currentTime = percent * duration;
                        }
                      }} style={{ cursor: 'pointer' }}>
                        <div className="progress-fill" style={{ width: `${progress}%` }} />
                      </div>
                      <div className="progress-text">
                        <span>{formatTime(currentTime)}</span>
                        <span>{formatTime(duration)}</span>
                      </div>
                    </div>

                    <div className={`speed-control ${carMode ? 'car-mode' : ''}`}>
                      <label>Speed</label>
                      <select value={speed} onChange={(e) => setSpeed(parseFloat(e.target.value))}>
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1">1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                      </select>
                    </div>
                  </div>
                </div>

                <div className="note-controls">
                  <button
                    className={`note-btn ${isProcessing ? 'processing' : ''} ${carMode ? 'car-mode' : ''}`}
                    onClick={handleVoiceButtonClick}
                    disabled={!speechReady || whisperLoading}
                    title={!speechReady ? 'Speech recognition not supported' : (useWhisperFallback ? 'Using offline mode' : '')}
                  >
                    {isRecording ? ' Stop' :
                     whisperLoading ? `Loading ${whisperProgress}%` :
                     isTranscribing ? 'Processing...' :
                     <><Icons.Mic /> Voice{useWhisperFallback ? ' (offline)' : ''}</>}
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    onClick={openTextNote}
                  >
                    <Icons.Keyboard /> Type
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    disabled={true}
                    title="Search not available for podcasts"
                    style={{ opacity: 0.5 }}
                  >
                    <Icons.Search /> Search
                  </button>
                  {isMobileDevice && (
                    <button
                      className={`note-btn ${carMode ? 'car-mode active' : ''}`}
                      onClick={() => setCarMode(!carMode)}
                      title="Car Mode"
                    >
                      <Icons.Car />
                    </button>
                  )}
                </div>
              </div>
            </div>
          ) : (
            <div className="empty-state">
              <div className="empty-state-icon"></div>
              <h3>Media Player</h3>
              <p>Paste a YouTube, Spotify, or podcast RSS feed link above to begin. The app will play it and let you take notes while you listen.</p>
            </div>
          )}
        </div>
      );
    });

    // Library View Component
    function LibraryView({ sources, notes, setCurrentSource, openSourceWithNotes, deleteNote, deleteSource, updateSource, setSources, setNotes, showToast }) {
      const groupedSources = sources.reduce((acc, source) => {
        const date = new Date(source.createdAt).toDateString();
        if (!acc[date]) acc[date] = [];
        acc[date].push(source);
        return acc;
      }, {});

      const getNotesForSource = (sourceId) => notes.filter(n => n.sourceId === sourceId).sort((a, b) => {
        if (a.timestamp !== undefined && b.timestamp !== undefined) return a.timestamp - b.timestamp;
        if (a.position !== undefined && b.position !== undefined) return a.position - b.position;
        return new Date(a.createdAt) - new Date(b.createdAt);
      });

      const exportToOneNote = () => {
        const getFirstThreeWords = (text) => {
          if (!text) return '';
          const words = text.trim().split(/\s+/).slice(0, 3);
          return words.join(' ');
        };

        let exportText = '';
        let firstSource = true;

        Object.entries(groupedSources).forEach(([date, dateSources]) => {
          dateSources.forEach(source => {
            const sourceNotes = getNotesForSource(source.id);

            // Add blank line between sources (except before first)
            if (!firstSource) {
              exportText += '\n';
            }
            firstSource = false;

            exportText += `${source.title} (${source.url || source.link || ''})\n`;

            if (sourceNotes.length > 0) {
              exportText += 'Notes:\n';
              sourceNotes.forEach(note => {
                let notePrefix = '';
                if (note.timestamp !== undefined) {
                  notePrefix = `[${formatTime(note.timestamp)}] `;
                } else if (note.position !== undefined && note.context) {
                  const firstThree = getFirstThreeWords(note.context);
                  notePrefix = `[Sentence ${note.position + 1} "${firstThree}..."] `;
                }
                exportText += `- ${notePrefix}${note.text}\n`;
              });
            }
          });
        });

        navigator.clipboard.writeText(exportText);
      };

      const exportLibrary = () => {
        // Include saved positions for articles/PDFs and media
        const readerPositions = JSON.parse(localStorage.getItem('harkenjot_positions') || '{}');
        const mediaPositions = JSON.parse(localStorage.getItem('harkenjot_media_positions') || '{}');

        const exportData = {
          version: 2,
          exportedAt: new Date().toISOString(),
          sources: sources,
          notes: notes,
          positions: {
            reader: readerPositions,
            media: mediaPositions
          }
        };

        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const now = new Date();
        const localDate = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
        a.download = `harkenjot-library-${localDate}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('Library exported');
      };

      const importLibrary = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const data = JSON.parse(event.target.result);

              if (!data.sources || !data.notes) {
                showToast('Invalid library file');
                return;
              }

              // Check if this is a single-source export (additive import)
              if (data.exportType === 'single-source') {
                const sourceTitle = data.sources[0]?.title || 'source';
                if (!confirm(`Add "${sourceTitle}" and ${data.notes.length} notes to your library? This will not overwrite existing items.`)) {
                  return;
                }

                // Additive import: merge with existing data
                const now = new Date().toISOString();
                setSources(prevSources => {
                  // Check if source already exists (by id)
                  const existingIds = new Set(prevSources.map(s => s.id));
                  // Update addedAt to current date so imports appear at top of library
                  const newSources = data.sources
                    .filter(s => !existingIds.has(s.id))
                    .map(s => ({ ...s, addedAt: now }));
                  return [...newSources, ...prevSources];
                });

                setNotes(prevNotes => {
                  // Check if notes already exist (by id)
                  const existingIds = new Set(prevNotes.map(n => n.id));
                  const newNotes = data.notes.filter(n => !existingIds.has(n.id));
                  return [...prevNotes, ...newNotes];
                });

                const addedSources = data.sources.length;
                const addedNotes = data.notes.length;
                showToast(`Added ${addedSources} source${addedSources !== 1 ? 's' : ''} and ${addedNotes} note${addedNotes !== 1 ? 's' : ''} to library`);
              } else {
                // Full library import (replaces everything)
                if (!confirm(`Import ${data.sources.length} sources and ${data.notes.length} notes? This will replace your current library.`)) {
                  return;
                }

                setSources(data.sources);
                setNotes(data.notes);

                // Restore saved positions if available (version 2+)
                if (data.positions) {
                  if (data.positions.reader) {
                    localStorage.setItem('harkenjot_positions', JSON.stringify(data.positions.reader));
                  }
                  if (data.positions.media) {
                    localStorage.setItem('harkenjot_media_positions', JSON.stringify(data.positions.media));
                  }
                }

                showToast(`Imported ${data.sources.length} sources and ${data.notes.length} notes`);
              }
            } catch (err) {
              showToast('Failed to import library');
            }
          };
          reader.readAsText(file);
        };
        input.click();
      };

      return (
        <div style={{ display: 'flex', flexDirection: 'column', flex: 1, minHeight: 0, overflow: 'hidden' }}>
          <div className="library-actions">
            <button className="btn btn-secondary" onClick={exportToOneNote}>
              <Icons.Copy /> Copy All
            </button>
            <button className="btn btn-secondary" onClick={importLibrary} title="Import Library">
              <Icons.FolderDown /> Import All
            </button>
            <button className="btn btn-secondary" onClick={exportLibrary} title="Export Library">
              <Icons.FolderUp /> Export All
            </button>
          </div>

          {sources.length === 0 ? (
            <div className="empty-state">
              <div className="empty-state-icon"></div>
              <h3>Library Empty</h3>
              <p>Your sources and notes will appear here. Start by adding an article or podcast in the Reader or Player tabs.</p>
            </div>
          ) : (
            <div className="library-grid" style={{ flex: 1, overflow: 'auto' }}>
              {Object.entries(groupedSources).map(([date, dateSources]) => (
                <div key={date} className="library-date-group">
                  <div className="date-header">{formatDate(new Date(date))}</div>
                  {dateSources.map(source => (
                    <div
                      key={source.id}
                      className="library-item"
                      onClick={() => setCurrentSource(source)}
                    >
                      <div className="library-item-top">
                        <div className="library-item-title">{source.title}</div>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', flexShrink: 0 }}>
                          <div
                            className={`read-status clickable ${source.isRead ? 'checked' : ''}`}
                            onClick={(e) => {
                              e.stopPropagation();
                              updateSource(source.id, { isRead: !source.isRead });
                            }}
                            title={source.isRead ? 'Mark as unread' : 'Mark as read'}
                          >
                            {source.isRead && <Icons.Check />}
                          </div>
                          <div
                            className="note-count"
                            onClick={(e) => {
                              e.stopPropagation();
                              openSourceWithNotes(source);
                            }}
                            style={{ cursor: 'pointer' }}
                            title="Open source and view notes"
                          >
                            {getNotesForSource(source.id).length} <Icons.Pencil />
                          </div>
                          <button
                            className="note-action-btn delete"
                            onClick={(e) => {
                              e.stopPropagation();
                              if (confirm('Delete this item and all its notes?')) {
                                deleteSource(source.id);
                              }
                            }}
                            title="Delete item"
                          >
                            <Icons.Trash />
                          </button>
                        </div>
                      </div>
                      <div className="library-item-meta">
                        <span className={`library-item-type ${source.type}`}>{source.type}</span>
                        {source.type === 'podcast' && source.showName && <span>{source.showName}</span>}
                        {source.type === 'youtube' && source.channelName && <span>{source.channelName}</span>}
                        {source.type !== 'podcast' && source.type !== 'youtube' && source.url && <span style={{ maxWidth: '200px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{safeHostname(source.url)}</span>}
                        {(source.type === 'podcast' || source.type === 'youtube') && <span>{source.duration ? formatTime(source.duration) : ''}</span>}
                        {(source.type === 'article' || source.type === 'pdf') && source.sentences && <span>{source.sentences.length} sentences</span>}
                        {(source.url || source.link) && <a href={source.link || source.url} target="_blank" rel="noopener noreferrer" onClick={(e) => e.stopPropagation()}><Icons.Link /></a>}
                      </div>
                    </div>
                  ))}
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }

    // Note Sidebar Component
    function NoteSidebar({ notes, currentSource, deleteNote, updateNote, navigateToNote, showToast, onClose }) {
      const [editingNoteId, setEditingNoteId] = useState(null);
      const [editText, setEditText] = useState('');

      const startEdit = (note) => {
        setEditingNoteId(note.id);
        setEditText(note.text);
      };

      const cancelEdit = () => {
        setEditingNoteId(null);
        setEditText('');
      };

      const saveEdit = (noteId) => {
        if (editText.trim()) {
          updateNote(noteId, editText.trim());
          setEditingNoteId(null);
          setEditText('');
        }
      };

      const copyNote = (note) => {
        const getFirstThreeWords = (text) => {
          if (!text) return '';
          const words = text.trim().split(/\s+/).slice(0, 3);
          return words.join(' ');
        };

        let notePrefix = '';
        if (note.timestamp !== undefined) {
          notePrefix = `[${formatTime(note.timestamp)}] `;
        } else if (note.position !== undefined && note.context) {
          const firstThree = getFirstThreeWords(note.context);
          notePrefix = `[Sentence ${note.position + 1} "${firstThree}..."] `;
        }

        const noteText = `${currentSource.title} (${currentSource.url || currentSource.link || ''})\nNotes:\n- ${notePrefix}${note.text}`;
        navigator.clipboard.writeText(noteText);
        showToast('Note copied to clipboard');
      };

      const exportAllNotes = () => {
        if (!currentSource) return;

        const getFirstThreeWords = (text) => {
          if (!text) return '';
          const words = text.trim().split(/\s+/).slice(0, 3);
          return words.join(' ');
        };

        let exportText = `${currentSource.title} (${currentSource.url || currentSource.link || ''})`;

        if (notes.length > 0) {
          exportText += `\nNotes:\n`;
          notes.forEach(note => {
            let notePrefix = '';
            if (note.timestamp !== undefined) {
              notePrefix = `[${formatTime(note.timestamp)}] `;
            } else if (note.position !== undefined && note.context) {
              const firstThree = getFirstThreeWords(note.context);
              notePrefix = `[Sentence ${note.position + 1} "${firstThree}..."] `;
            }
            exportText += `- ${notePrefix}${note.text}\n`;
          });
        }

        navigator.clipboard.writeText(exportText);
        showToast(notes.length > 0 ? 'All notes copied to clipboard' : 'Title and link copied to clipboard');
      };

      const exportCurrentSource = () => {
        if (!currentSource) return;

        const exportData = {
          version: 2,
          exportType: 'single-source',
          exportedAt: new Date().toISOString(),
          sources: [currentSource],
          notes: notes
        };

        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const now = new Date();
        const localDate = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
        // Sanitize title for filename
        const safeTitle = (currentSource.title || 'source').replace(/[^a-zA-Z0-9]/g, '-').substring(0, 30);
        a.download = `harkenjot-${safeTitle}-${localDate}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('Source and notes exported');
      };

      return (
        <div>
          <div className="sidebar-title" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <span><Icons.Pencil /> Notes ({notes.length})</span>
            {onClose && (
              <button
                onClick={onClose}
                className="btn btn-secondary btn-icon"
                style={{ width: '32px', height: '32px', padding: 0 }}
              >
                <Icons.X />
              </button>
            )}
          </div>

          <div className="export-section" style={{ marginTop: '0.5rem', marginBottom: '0.5rem', borderTop: 'none', display: 'flex', gap: '0.5rem' }}>
            <button className="export-btn" onClick={exportAllNotes} style={{ flex: 1 }}>
              <Icons.Copy /> Copy
            </button>
            <button className="export-btn" onClick={exportCurrentSource} style={{ flex: 1 }}>
              <Icons.FolderUp /> Export
            </button>
          </div>

          {notes.length === 0 ? (
            <div style={{ textAlign: 'center', padding: '2rem 1rem', color: 'var(--text-muted)' }}>
              <Icons.Mic />
              <p style={{ marginTop: '0.5rem', fontSize: '0.875rem' }}>
                Click "Voice" or "Type" while listening to take notes.
              </p>
            </div>
          ) : (
            <div className="notes-list">
              {notes.map(note => (
                <div key={note.id} className="note-card">
                  <div
                    className="note-position"
                    onClick={() => navigateToNote(note)}
                    style={{ cursor: 'pointer' }}
                    title="Click to navigate to this location"
                  >
                    {note.timestamp !== undefined
                      ? formatTime(note.timestamp)
                      : `Sentence ${note.position + 1}`}
                  </div>

                  {editingNoteId === note.id ? (
                    // Edit mode
                    <>
                      <textarea
                        className="note-edit-input"
                        value={editText}
                        onChange={(e) => setEditText(e.target.value)}
                        autoFocus
                        rows="4"
                      />
                      <div className="note-actions">
                        <button className="note-action-btn" onClick={() => saveEdit(note.id)}>
                          Save
                        </button>
                        <button className="note-action-btn" onClick={cancelEdit}>
                          Cancel
                        </button>
                      </div>
                    </>
                  ) : (
                    // View mode
                    <>
                      <div className="note-text">{note.text}</div>
                      {note.context && (
                        <div className="note-context">"{note.context}"</div>
                      )}
                      <div className="note-actions">
                        <button className="note-action-btn" onClick={() => startEdit(note)}>
                          <Icons.Edit /> Edit
                        </button>
                        <button className="note-action-btn" onClick={() => copyNote(note)}>
                          <Icons.Copy /> Copy
                        </button>
                        <button className="note-action-btn delete" onClick={() => deleteNote(note.id)}>
                          <Icons.Trash /> Delete
                        </button>
                      </div>
                    </>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }

    // Render the app
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>