<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HarkenJot - Take Notes While You Listen</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script type="module">
    // Whisper Speech Recognition using Transformers.js
    import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1';

    // Configure transformers.js
    env.allowLocalModels = false;

    let whisperPipeline = null;
    let isLoadingModel = false;

    const whisperASR = {
      isReady: false,
      isLoading: false,
      progress: 0,
      error: null,

      async loadModel(onProgress) {
        if (whisperPipeline) {
          this.isReady = true;
          return true;
        }
        if (isLoadingModel) return false;

        isLoadingModel = true;
        this.isLoading = true;
        this.error = null;

        try {
          console.log('Loading Whisper model...');
          whisperPipeline = await pipeline(
            'automatic-speech-recognition',
            'Xenova/whisper-tiny.en',
            {
              progress_callback: (progress) => {
                if (progress.status === 'progress') {
                  this.progress = Math.round(progress.progress);
                  if (onProgress) onProgress(this.progress);
                }
                console.log('Model load progress:', progress);
              }
            }
          );
          console.log('Whisper model loaded successfully');
          this.isReady = true;
          this.isLoading = false;
          isLoadingModel = false;
          return true;
        } catch (error) {
          console.error('Failed to load Whisper model:', error);
          this.error = error.message;
          this.isLoading = false;
          isLoadingModel = false;
          return false;
        }
      },

      async transcribe(audioBlob) {
        if (!whisperPipeline) {
          throw new Error('Whisper model not loaded');
        }

        try {
          console.log('Transcribing audio...', audioBlob.size, 'bytes, type:', audioBlob.type);

          // Decode audio blob to raw audio samples using Web Audio API
          const arrayBuffer = await audioBlob.arrayBuffer();
          console.log('ArrayBuffer size:', arrayBuffer.byteLength);

          // Try different sample rates - some browsers need native rate first
          let audioContext;
          let audioBuffer;

          // First try without forcing sample rate (more compatible)
          try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
            console.log('Decoded at native rate:', audioBuffer.sampleRate, 'Hz');
          } catch (e) {
            console.log('Native decode failed, trying 16kHz:', e.message);
            if (audioContext) await audioContext.close().catch(() => {});
            audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
          }

          // Get audio data as Float32Array (mono for Whisper)
          let audioData;
          if (audioBuffer.numberOfChannels > 1) {
            // Mix down to mono
            const left = audioBuffer.getChannelData(0);
            const right = audioBuffer.getChannelData(1);
            audioData = new Float32Array(left.length);
            for (let i = 0; i < left.length; i++) {
              audioData[i] = (left[i] + right[i]) / 2;
            }
          } else {
            audioData = audioBuffer.getChannelData(0);
          }

          // Resample to 16kHz if needed (Whisper requires 16kHz)
          if (audioBuffer.sampleRate !== 16000) {
            console.log('Resampling from', audioBuffer.sampleRate, 'to 16000 Hz');
            const ratio = audioBuffer.sampleRate / 16000;
            const newLength = Math.round(audioData.length / ratio);
            const resampled = new Float32Array(newLength);
            for (let i = 0; i < newLength; i++) {
              const srcIndex = Math.floor(i * ratio);
              resampled[i] = audioData[srcIndex];
            }
            audioData = resampled;
          }

          console.log('Audio ready:', audioData.length, 'samples at 16kHz');

          if (audioData.length < 1600) { // Less than 0.1 seconds
            throw new Error('Audio too short');
          }

          const result = await whisperPipeline(audioData, {
            chunk_length_s: 30,
            stride_length_s: 5,
            language: 'english',
            task: 'transcribe',
            sampling_rate: 16000,
          });
          console.log('Transcription result:', result);
          await audioContext.close();
          return result.text || '';
        } catch (error) {
          console.error('Transcription error:', error);
          throw error;
        }
      },

      getSupportedMimeType() {
        // More comprehensive list including codecs for better mobile support
        const types = [
          'audio/webm;codecs=opus',
          'audio/webm',
          'audio/mp4',
          'audio/ogg;codecs=opus',
          'audio/ogg',
          'audio/wav',
          'audio/mpeg',
          ''  // Empty string = browser default
        ];
        for (const type of types) {
          if (type === '' || MediaRecorder.isTypeSupported(type)) {
            console.log('Using audio format:', type || 'browser default');
            return type;
          }
        }
        console.log('Using default audio format');
        return '';
      }
    };

    // Make it globally available
    window.WhisperASR = whisperASR;
    console.log('WhisperASR initialized');
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,500;0,600;1,400&family=DM+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #faf8f5;
      --bg-secondary: #f4f1eb;
      --bg-tertiary: #ebe7df;
      --text-primary: #2d2a26;
      --text-secondary: #5c5751;
      --text-muted: #8a847a;
      --accent: #c45a3b;
      --accent-hover: #a84830;
      --accent-soft: #f8ebe7;
      --border: #ddd8cf;
      --shadow: rgba(45, 42, 38, 0.08);
      --note-bg: #fff9e6;
      --note-border: #f0e4b8;
      --success: #4a7c59;
      --recording: #c45a3b;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      height: 100dvh;
      min-height: 500px;
      overflow: hidden;
    }

    body {
      font-family: 'DM Sans', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      background-blend-mode: overlay;
      background-size: 200px;
    }

    .app-container {
      max-width: 1400px;
      margin: 0 auto;
      height: 100%;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 2rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-primary);
      z-index: 100;
      flex-shrink: 0;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .logo-icon {
      width: 36px;
      height: 36px;
      background: var(--accent);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-family: 'Crimson Pro', serif;
      font-size: 1.25rem;
      font-weight: 600;
    }

    .logo-text {
      font-family: 'Crimson Pro', serif;
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .logo-tagline {
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-top: -0.125rem;
    }

    /* Navigation */
    .nav-tabs {
      display: flex;
      gap: 0.25rem;
      background: var(--bg-secondary);
      padding: 0.25rem;
      border-radius: 10px;
    }

    .nav-tab {
      padding: 0.5rem 1rem;
      border: none;
      background: transparent;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-secondary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .nav-tab:hover {
      color: var(--text-primary);
    }

    .nav-tab.active {
      background: white;
      color: var(--text-primary);
      box-shadow: 0 2px 8px var(--shadow);
    }

    .notes-button {
      margin-left: auto;
      border: 1px solid var(--border);
      background: var(--bg-primary);
    }

    .notes-button:hover:not(:disabled) {
      background: var(--bg-secondary);
      border-color: var(--accent);
    }

    .notes-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .notes-button.active:not(:disabled) {
      background: var(--accent) !important;
      color: white !important;
      border-color: var(--accent) !important;
      box-shadow: 0 2px 8px var(--shadow);
    }

    /* Main Content */
    .main-content {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    .content-area {
      padding: 1rem 2rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

    .sidebar {
      position: fixed;
      right: -360px;
      top: 60px;
      height: calc(100% - 60px);
      height: calc(100dvh - 60px);
      width: 360px;
      padding: 1rem;
      background: var(--bg-secondary);
      overflow-y: auto;
      min-height: 0;
      transition: right 0.3s ease;
      box-shadow: -4px 0 20px var(--shadow);
      z-index: 50;
    }

    .sidebar.open {
      right: 0;
    }

    /* Input Section */
    .input-section {
      margin-bottom: 1rem;
      flex-shrink: 0;
    }

    .input-group {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .url-input {
      flex: 1;
      min-width: 0;
      padding: 0.75rem 1rem;
      border: 2px solid var(--border);
      border-radius: 10px;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.875rem;
      background: white;
      transition: all 0.2s ease;
    }

    .url-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-soft);
    }

    .url-input::placeholder {
      color: var(--text-muted);
    }

    .btn {
      padding: 0.75rem 1.25rem;
      border: none;
      border-radius: 10px;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: var(--border);
    }

    .btn-icon {
      width: 40px;
      height: 40px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
    }

    /* Reader Section */
    .reader-container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 24px var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    .reader-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 1rem;
      flex-shrink: 0;
    }

    .source-info h2 {
      font-family: 'Crimson Pro', serif;
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
      line-height: 1.3;
    }

    .source-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .source-meta a {
      color: var(--accent);
      text-decoration: none;
    }

    .source-meta a:hover {
      text-decoration: underline;
    }

    .reader-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-shrink: 0;
    }

    .reader-body {
      padding: 1rem 1.5rem;
      flex: 1;
      min-height: 0;
      overflow-y: auto;
    }

    .reader-content {
      font-family: 'Crimson Pro', serif;
      font-size: 1rem;
      line-height: 1.7;
      color: var(--text-primary);
    }

    .reader-content p {
      margin-bottom: 1rem;
    }

    .sentence {
      transition: all 0.2s ease;
      border-radius: 4px;
      padding: 0 2px;
      margin: 0 -2px;
    }

    .sentence.current {
      background: var(--accent-soft);
      color: var(--accent);
    }

    .sentence.has-note {
      background: var(--note-bg);
      border-bottom: 2px solid var(--note-border);
      cursor: pointer;
    }

    .sentence.has-note:hover {
      background: #fff3c4;
    }

    /* Playback Bar */
    .playback-bar {
      padding: 0.75rem 1.5rem;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-shrink: 0;
      flex-wrap: wrap;
    }

    .playback-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex: 1;
      min-width: 0;
      flex-wrap: wrap;
    }

    .transport-buttons {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .progress-speed-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex: 1;
      min-width: 0;
    }

    .note-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    @media (max-width: 700px) {
      .playback-controls {
        width: 100%;
        justify-content: center;
      }

      .transport-buttons {
        order: 1;
      }

      .progress-speed-group {
        order: 2;
        flex: 1;
        min-width: 0;
        flex-direction: column;
        gap: 0.25rem;
        align-items: stretch;
      }

      .progress-speed-group .progress-container {
        width: 100%;
      }

      .note-controls {
        order: 3;
        width: 100%;
        justify-content: center;
        padding: 0;
        border: none;
        margin: 0;
      }
    }

    .play-btn {
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .play-btn svg {
      width: 24px;
      height: 24px;
    }

    .play-btn:hover {
      background: var(--accent-hover);
      transform: scale(1.05);
    }

    .skip-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .skip-btn:hover:not(:disabled) {
      background: var(--border);
      transform: scale(1.05);
    }

    .skip-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .play-btn.recording {
      background: var(--recording);
      animation: pulse 1.5s ease infinite;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(196, 90, 59, 0.4); }
      50% { box-shadow: 0 0 0 12px rgba(196, 90, 59, 0); }
    }

    .progress-container {
      flex: 1;
    }

    .progress-bar {
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 0.25rem;
    }

    .progress-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      transition: width 0.1s linear;
    }

    .progress-text {
      font-size: 0.7rem;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.375rem 0.625rem;
      background: white;
      border-radius: 8px;
      border: 1px solid var(--border);
      flex-shrink: 0;
    }

    .speed-control label {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .speed-control select {
      border: none;
      background: transparent;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-primary);
      cursor: pointer;
    }

    /* Voice Note Button */
    .note-btn {
      padding: 0.625rem 0.75rem;
      background: var(--note-bg);
      border: 2px solid var(--note-border);
      border-radius: 10px;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.375rem;
      transition: all 0.2s ease;
      flex: 1;
      min-height: 44px;
      white-space: nowrap;
    }

    .note-btn svg {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }

    @media (max-width: 600px) {
      .note-controls {
        gap: 0.375rem;
      }

      .note-btn {
        padding: 0.5rem 0.5rem;
        font-size: 0.7rem;
      }

      .note-btn svg {
        width: 16px;
        height: 16px;
      }
    }

    .note-btn:hover {
      background: #fff3c4;
      border-color: #e6d9a5;
    }

    .note-btn.recording,
    .note-btn.processing {
      background: #fee2e2;
      border-color: var(--recording);
      color: var(--recording);
      animation: pulse-note 1.5s ease infinite;
    }

    @keyframes pulse-note {
      0%, 100% { box-shadow: 0 0 0 0 rgba(196, 90, 59, 0.3); }
      50% { box-shadow: 0 0 0 8px rgba(196, 90, 59, 0); }
    }

    /* Note controls responsive */
    .note-controls {
      flex-wrap: nowrap;
    }

    /* Car button - square in regular mode */
    .note-btn:nth-child(4):not(.car-mode) {
      flex: 0 0 auto;
      aspect-ratio: 1;
      padding: 0.5rem;
    }

    /* Car Mode */
    .playback-bar.car-mode {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: stretch;
      padding: 1rem;
      gap: 1rem;
      min-height: 0;
    }

    .playback-bar.car-mode .playback-controls {
      width: 100%;
      flex-direction: column;
      gap: 0.75rem;
      flex: 0 0 auto;
      justify-content: flex-start;
    }

    .playback-bar.car-mode .transport-buttons {
      flex: 0 0 auto;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.75rem;
      width: 100%;
    }

    .skip-btn.car-mode,
    .play-btn.car-mode {
      flex: 1;
      max-width: none;
      width: auto;
      height: auto;
      min-width: 60px;
      min-height: 60px;
      font-size: 2rem;
      aspect-ratio: 1;
    }

    .skip-btn.car-mode svg,
    .play-btn.car-mode svg {
      width: 50%;
      height: 50%;
      max-width: 80px;
      max-height: 80px;
    }

    .progress-speed-group.car-mode {
      display: flex;
      width: 100%;
      flex-direction: row;
      gap: 1rem;
      flex-shrink: 0;
      align-items: center;
      margin-top: 0.5rem;
    }

    .progress-speed-group.car-mode .progress-container {
      flex: 1;
    }

    .progress-bar.car-mode {
      height: 8px;
    }

    .speed-control.car-mode {
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    .speed-control.car-mode label {
      font-size: 0.7rem;
      margin: 0;
      line-height: 1;
    }

    .speed-control.car-mode select {
      font-size: 0.8125rem;
      padding: 0;
      border: none;
      background: transparent;
      line-height: 1;
    }

    .playback-bar.car-mode .note-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 0.75rem;
      width: 100%;
      flex: 1;
      min-height: 0;
    }

    /* All note buttons same size */
    .note-btn.car-mode {
      width: 100%;
      height: 100%;
      padding: 1rem;
      font-size: 1.25rem;
      min-height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .note-btn.car-mode svg {
      width: 40px;
      height: 40px;
    }

    .note-btn.car-mode.active {
      background: var(--accent-soft);
      border-color: var(--accent);
      color: var(--accent);
    }

    @media (max-width: 500px) {
      .playback-bar.car-mode {
        padding: 0.75rem;
        gap: 0.75rem;
      }

      .playback-bar.car-mode .playback-controls {
        gap: 0.75rem;
      }

      .playback-bar.car-mode .transport-buttons {
        gap: 0.5rem;
      }

      .skip-btn.car-mode,
      .play-btn.car-mode {
        min-width: 50px;
        min-height: 50px;
        aspect-ratio: 1;
      }

      .note-btn.car-mode {
        min-height: 70px;
        font-size: 1rem;
        padding: 0.75rem;
      }

      .note-btn.car-mode svg {
        width: 28px;
        height: 28px;
      }

      .progress-speed-group.car-mode {
        gap: 0.75rem;
      }

      .speed-control.car-mode select {
        font-size: 0.75rem;
      }
    }

    /* Sidebar Notes */
    .sidebar-title {
      font-family: 'Crimson Pro', serif;
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .notes-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .note-card {
      background: white;
      border-radius: 8px;
      padding: 0.75rem;
      box-shadow: 0 2px 8px var(--shadow);
      border-left: 3px solid var(--accent);
    }

    .note-position {
      font-size: 0.7rem;
      color: var(--accent);
      font-weight: 500;
      margin-bottom: 0.25rem;
      font-family: 'JetBrains Mono', monospace;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .note-position:hover {
      opacity: 0.7;
    }

    .note-text {
      font-size: 0.875rem;
      color: var(--text-primary);
      line-height: 1.4;
      margin-bottom: 0.375rem;
    }

    .note-edit-input {
      width: 100%;
      font-size: 0.875rem;
      color: var(--text-primary);
      line-height: 1.4;
      padding: 0.5rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-primary);
      font-family: inherit;
      resize: vertical;
      margin-bottom: 0.5rem;
    }

    .note-edit-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .note-context {
      font-size: 0.75rem;
      color: var(--text-muted);
      font-style: italic;
      padding-left: 0.5rem;
      border-left: 2px solid var(--border);
    }

    .note-actions {
      display: flex;
      gap: 0.375rem;
      margin-top: 0.5rem;
    }

    .note-action-btn {
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--border);
      background: var(--bg-primary);
      border-radius: 6px;
      font-size: 0.7rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .note-action-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .note-action-btn.delete:hover {
      border-color: #dc2626;
      color: #dc2626;
    }

    /* Library View */
    .library-grid {
      display: grid;
      gap: 1rem;
    }

    .library-date-group {
      margin-bottom: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .date-header {
      font-family: 'Crimson Pro', serif;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-secondary);
      padding-bottom: 0.5rem;
      border-bottom: 2px solid var(--border);
      margin-bottom: 0.75rem;
    }

    .library-item {
      background: white;
      border-radius: 10px;
      padding: 1rem;
      box-shadow: 0 2px 12px var(--shadow);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .library-item-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.75rem;
    }

    .library-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px var(--shadow);
    }

    .library-item-title {
      font-family: 'Crimson Pro', serif;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .library-item-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .library-item-meta a {
      color: var(--accent);
      display: flex;
      align-items: center;
    }

    .library-item-meta a:hover {
      color: var(--accent-hover);
    }

    .library-item-type {
      padding: 0.1875rem 0.5rem;
      background: var(--bg-secondary);
      border-radius: 4px;
      font-size: 0.625rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
    }

    .library-item-type.article { background: #dbeafe; color: #1e40af; }
    .library-item-type.pdf { background: #fee2e2; color: #991b1b; }
    .library-item-type.youtube { background: #fce7f3; color: #9d174d; }
    .library-item-type.podcast { background: #d1fae5; color: #065f46; }

    .note-count {
      padding: 0.25rem 0.5rem;
      background: var(--note-bg);
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    /* Media Player Section */
    .media-container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 24px var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    .youtube-container {
      flex: 1;
      min-height: 0;
      background: #000;
      position: relative;
    }

    .youtube-container iframe {
      width: 100%;
      height: 100%;
    }

    .audio-visualizer {
      height: 80px;
      background: linear-gradient(180deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .audio-bar {
      width: 4px;
      background: var(--accent);
      border-radius: 2px;
      transition: height 0.1s ease;
    }

    /* Empty States */
    .empty-state {
      text-align: center;
      padding: 2rem 1rem;
      color: var(--text-muted);
    }

    .empty-state-icon {
      width: 60px;
      height: 60px;
      margin: 0 auto 1rem;
      background: var(--bg-secondary);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }

    .empty-state h3 {
      font-family: 'Crimson Pro', serif;
      font-size: 1.25rem;
      color: var(--text-secondary);
      margin-bottom: 0.375rem;
    }

    .empty-state p {
      font-size: 0.875rem;
      max-width: 400px;
      margin: 0 auto;
    }

    /* Export Section */
    .export-section {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }

    .export-btn {
      width: 100%;
      padding: 0.625rem;
      background: var(--bg-tertiary);
      border: 2px dashed var(--border);
      border-radius: 8px;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.8rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.375rem;
    }

    .export-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--accent-soft);
    }

    /* Tabs for Media */
    .media-tabs {
      display: flex;
      gap: 0;
      background: var(--bg-tertiary);
      border-radius: 8px;
      padding: 0.25rem;
      margin-bottom: 0.75rem;
      flex-shrink: 0;
    }

    .media-tab {
      flex: 1;
      padding: 0.5rem 1rem;
      border: none;
      background: transparent;
      font-family: 'DM Sans', sans-serif;
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s ease;
    }

    .media-tab.active {
      background: white;
      color: var(--text-primary);
      box-shadow: 0 1px 4px var(--shadow);
    }

    /* Subscription List */
    .subscription-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
      flex-shrink: 0;
      max-height: 150px;
      overflow-y: auto;
    }

    .subscription-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .subscription-item:hover {
      background: var(--bg-tertiary);
    }

    .subscription-item.active {
      background: var(--accent-soft);
      border: 1px solid var(--accent);
    }

    .subscription-thumb {
      width: 36px;
      height: 36px;
      border-radius: 6px;
      background: var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      flex-shrink: 0;
    }

    .subscription-info {
      flex: 1;
      min-width: 0;
    }

    .subscription-title {
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .subscription-channel {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    /* Toast Notification */
    .toast {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--text-primary);
      color: white;
      padding: 0.875rem 1.5rem;
      border-radius: 10px;
      font-size: 0.9375rem;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .toast {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .undo-btn {
      background: white;
      color: var(--text-primary);
      border: none;
      padding: 0.375rem 0.75rem;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .undo-btn:hover {
      background: var(--bg-secondary);
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
    }

    .modal-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: white;
      border-radius: 16px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow: auto;
      transform: scale(0.95);
      transition: all 0.2s ease;
    }

    .modal-overlay.show .modal {
      transform: scale(1);
    }

    .modal-header {
      padding: 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal-title {
      font-family: 'Crimson Pro', serif;
      font-size: 1.375rem;
      font-weight: 600;
    }

    .modal-close {
      width: 36px;
      height: 36px;
      border: none;
      background: var(--bg-secondary);
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      color: var(--text-secondary);
    }

    .modal-close:hover {
      background: var(--bg-tertiary);
    }

    .modal-body {
      padding: 1.5rem;
    }

    .modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
    }

    /* Text Note Input */
    .text-note-container {
      padding: 0.75rem 1.5rem;
      background: var(--note-bg);
      border-top: 1px solid var(--note-border);
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .text-note-input {
      flex: 1;
    }

    .text-note-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .search-container {
      padding: 0.75rem 1.5rem;
      background: var(--note-bg);
      border-top: 1px solid var(--note-border);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .search-container > .url-input {
      flex: 1;
    }

    .search-results {
      max-height: 300px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .search-result-item {
      padding: 0.75rem;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      border: 1px solid var(--border);
      transition: all 0.2s ease;
    }

    .search-result-item:hover {
      background: var(--bg-secondary);
      border-color: var(--accent);
    }

    /* Library Actions */
    .library-actions {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      flex-shrink: 0;
      flex-wrap: wrap;
    }

    .library-actions .btn {
      padding: 0.5rem 0.75rem;
    }

    /* Responsive */
    @media (max-width: 640px) {
      .header {
        flex-direction: column;
        gap: 0.5rem;
        padding: 0.75rem 1rem;
      }

      .library-actions {
        justify-content: center;
      }

      .logo-text {
        font-size: 1.5rem;
      }

      .logo-icon {
        width: 32px;
        height: 32px;
        font-size: 1.25rem;
      }

      .content-area {
        padding: 0.75rem 1rem;
      }

      .input-group {
        gap: 0.5rem;
      }

      .reader-header {
        flex-direction: column;
        padding: 0.75rem 1rem;
      }

      .source-info h2 {
        font-size: 1.1rem;
      }

      .reader-body {
        padding: 0.75rem 1rem;
      }

      .reader-content {
        font-size: 0.9rem;
        line-height: 1.6;
      }

      .playback-bar {
        flex-wrap: wrap;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
      }

      .play-btn {
        width: 56px;
        height: 56px;
      }

      .play-btn svg {
        width: 26px;
        height: 26px;
      }

      .skip-btn {
        width: 52px;
        height: 52px;
      }

      .skip-btn svg {
        width: 22px;
        height: 22px;
      }

      /* Note: .note-btn padding handled by more aggressive media queries below */

      .note-btn svg {
        width: 22px;
        height: 22px;
      }

      .speed-control {
        padding: 0.375rem 0.5rem;
      }

      .speed-control label {
        font-size: 0.7rem;
      }

      .speed-control select {
        font-size: 0.8rem;
      }

      .nav-tab {
        padding: 0.5rem 0.75rem;
        font-size: 0.8rem;
      }

      .text-note-container {
        flex-direction: column;
        align-items: stretch;
        padding: 0.75rem 1rem;
      }

      .text-note-input {
        width: 100%;
        margin-bottom: 0.5rem;
      }

      .text-note-buttons {
        width: 100%;
        justify-content: stretch;
      }

      .text-note-buttons .btn {
        flex: 1;
      }

      .search-container {
        padding: 0.75rem 1rem;
      }
    }

    @media (max-height: 700px) {
      .header {
        padding: 0.5rem 1rem;
      }

      .logo-tagline {
        display: none;
      }

      .content-area {
        padding: 0.5rem 1rem;
      }

      .reader-header {
        padding: 0.5rem 1rem;
      }

      .reader-body {
        padding: 0.5rem 1rem;
      }

      .playback-bar {
        padding: 0.5rem 1rem;
      }

      .empty-state {
        padding: 1rem;
      }

      .empty-state-icon {
        width: 48px;
        height: 48px;
        font-size: 1.25rem;
      }
    }

    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback, useImperativeHandle } = React;

    // Icons
    const Icons = {
      Play: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>,
      Pause: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>,
      Mic: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>,
      MicOff: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"/><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>,
      Book: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>,
      Library: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><line x1="8" y1="6" x2="16" y2="6"/><line x1="8" y1="10" x2="16" y2="10"/><line x1="8" y1="14" x2="12" y2="14"/></svg>,
      Headphones: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 18v-6a9 9 0 0 1 18 0v6"/><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"/></svg>,
      Link: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>,
      Copy: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>,
      Trash: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>,
      X: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>,
      Menu: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>,
      StickyNote: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M15.5 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3Z"/><path d="M15 3v6h6"/></svg>,
      Download: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>,
      YouTube: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M23.5 6.2c-.3-1-1-1.8-2-2.1C19.6 3.5 12 3.5 12 3.5s-7.6 0-9.5.5c-1 .3-1.7 1.1-2 2.1C0 8.1 0 12 0 12s0 3.9.5 5.8c.3 1 1 1.8 2 2.1 1.9.5 9.5.5 9.5.5s7.6 0 9.5-.5c1-.3 1.7-1.1 2-2.1.5-1.9.5-5.8.5-5.8s0-3.9-.5-5.8zM9.5 15.5v-7l6.4 3.5-6.4 3.5z"/></svg>,
      Podcast: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M13 17a1 1 0 1 0-2 0l.5 4.5a.5.5 0 0 0 1 0z" fill="currentColor"/><path d="M16.85 18.58a9 9 0 1 0-9.7 0"/><path d="M8 14a5 5 0 1 1 8 0"/><circle cx="12" cy="11" r="1" fill="currentColor"/></svg>,
      Edit: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>,
      Plus: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
      FileText: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>,
      SkipBack: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19 20L9 12l10-8v16zM5 19V5h2v14H5z"/></svg>,
      SkipForward: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M5 4l10 8-10 8V4zm14 1v14h-2V5h2z"/></svg>,
      Rewind: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M11 19l-9-7 9-7v14z"/><path d="M22 19l-9-7 9-7v14z"/></svg>,
      FastForward: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M13 19l9-7-9-7v14z"/><path d="M2 19l9-7-9-7v14z"/></svg>,
      Search: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>,
      Car: () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 17h2c.6 0 1-.4 1-1v-3.15a1 1 0 0 0-.84-.99L16 11l-2.7-3.6a1 1 0 0 0-.8-.4H5.24a2 2 0 0 0-1.8 1.1l-.8 1.63A6 6 0 0 0 2 12.42V16h2"/><circle cx="6.5" cy="16.5" r="2.5"/><circle cx="16.5" cy="16.5" r="2.5"/></svg>,
      BookOpen: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>,
      Library: () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="m16 6 4 14"/><path d="M12 6v14"/><path d="M8 8v12"/><path d="M4 4v16"/></svg>,
      Keyboard: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="20" height="16" x="2" y="4" rx="2"/><path d="M6 8h.01"/><path d="M10 8h.01"/><path d="M14 8h.01"/><path d="M18 8h.01"/><path d="M8 12h.01"/><path d="M12 12h.01"/><path d="M16 12h.01"/><path d="M7 16h10"/></svg>,
      Pencil: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>,
      FolderDown: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"/><path d="M12 10v6"/><path d="m15 13-3 3-3-3"/></svg>,
      FolderUp: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"/><path d="M12 10v6"/><path d="m9 13 3-3 3 3"/></svg>,
    };

    // Utility functions
    const generateId = () => Math.random().toString(36).substr(2, 9);
    const formatDate = (date) => new Date(date).toLocaleDateString('en-US', { 
      weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
    });
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    // Toast Component
    function Toast({ message, show, onUndo, showUndo }) {
      return (
        <div className={`toast ${show ? 'show' : ''}`}>
          <span>{message}</span>
          {showUndo && onUndo && (
            <button className="undo-btn" onClick={onUndo}>
              Undo
            </button>
          )}
        </div>
      );
    }

    // Audio feedback utility
    const playSound = (type) => {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.type = 'sine';
        gainNode.gain.value = 0.3; // Volume

        const now = audioContext.currentTime;

        if (type === 'start') {
          // High beep for start recording
          oscillator.frequency.value = 800;
          gainNode.gain.setValueAtTime(0.3, now);
          gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
          oscillator.start(now);
          oscillator.stop(now + 0.1);
        } else if (type === 'stop') {
          // Low beep for stop recording
          oscillator.frequency.value = 400;
          gainNode.gain.setValueAtTime(0.3, now);
          gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
          oscillator.start(now);
          oscillator.stop(now + 0.1);
        } else if (type === 'success') {
          // Two-tone chime for success
          oscillator.frequency.setValueAtTime(523, now);
          oscillator.frequency.setValueAtTime(659, now + 0.1);
          gainNode.gain.setValueAtTime(0.3, now);
          gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
          oscillator.start(now);
          oscillator.stop(now + 0.3);
        } else if (type === 'error') {
          // Low buzz for error
          oscillator.type = 'square';
          oscillator.frequency.value = 200;
          gainNode.gain.setValueAtTime(0.2, now);
          gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
          oscillator.start(now);
          oscillator.stop(now + 0.2);
        }
      } catch (err) {
        console.log('Audio feedback unavailable:', err);
      }
    };

    // Migrate localStorage from old 'marginalia_' keys to new 'harkenjot_' keys
    (function migrateLocalStorage() {
      const migrations = [
        ['marginalia_sources', 'harkenjot_sources'],
        ['marginalia_notes', 'harkenjot_notes'],
        ['harkenjot_positions', 'harkenjot_positions'],
        ['harkenjot_subscriptions', 'harkenjot_subscriptions'],
        ['harkenjot_media_positions', 'harkenjot_media_positions']
      ];
      migrations.forEach(([oldKey, newKey]) => {
        const oldData = localStorage.getItem(oldKey);
        if (oldData && !localStorage.getItem(newKey)) {
          localStorage.setItem(newKey, oldData);
          localStorage.removeItem(oldKey);
        }
      });
    })();

    // Main App
    function App() {
      const [activeTab, setActiveTab] = useState('reader');
      const [sources, setSources] = useState(() => {
        const saved = localStorage.getItem('harkenjot_sources');
        return saved ? JSON.parse(saved) : [];
      });
      const [currentSource, setCurrentSource] = useState(null);
      const [notes, setNotes] = useState(() => {
        const saved = localStorage.getItem('harkenjot_notes');
        return saved ? JSON.parse(saved) : [];
      });
      const [toast, setToast] = useState({ show: false, message: '' });
      const [sidebarOpen, setSidebarOpen] = useState(false);
      const [undoData, setUndoData] = useState(null);
      const [carMode, setCarMode] = useState(false);
      const [isMobileDevice, setIsMobileDevice] = useState(false);

      const readerRef = useRef(null);
      const mediaRef = useRef(null);
      const undoTimeoutRef = useRef(null);

      // Detect if user is on a mobile device
      useEffect(() => {
        const checkMobile = () => {
          const userAgent = navigator.userAgent || navigator.vendor || window.opera;
          // Check for mobile devices (iOS, Android, Windows Phone)
          const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
          setIsMobileDevice(isMobile);
        };
        checkMobile();
      }, []);

      // Save to localStorage
      useEffect(() => {
        localStorage.setItem('harkenjot_sources', JSON.stringify(sources));
      }, [sources]);

      useEffect(() => {
        localStorage.setItem('harkenjot_notes', JSON.stringify(notes));
      }, [notes]);

      // Close sidebar when changing tabs
      useEffect(() => {
        setSidebarOpen(false);
      }, [activeTab]);

      // Ensure voices are loaded
      useEffect(() => {
        // Load voices immediately if available
        const voices = window.speechSynthesis.getVoices();

        // Some browsers load voices asynchronously
        if (!voices.length) {
          window.speechSynthesis.addEventListener('voiceschanged', () => {
            window.speechSynthesis.getVoices();
          }, { once: true });
        }
      }, []);

      const showToast = (message) => {
        setToast({ show: true, message });
        setTimeout(() => setToast({ show: false, message: '' }), 3000);
      };

      const addSource = (source) => {
        const newSource = { ...source, id: generateId(), createdAt: new Date().toISOString() };
        setSources(prev => [newSource, ...prev]);
        setCurrentSource(newSource);
        showToast('Source added to library');
        return newSource;
      };

      const updateSource = (sourceId, updates) => {
        setSources(prev => prev.map(s => s.id === sourceId ? { ...s, ...updates } : s));
        setCurrentSource(prev => prev?.id === sourceId ? { ...prev, ...updates } : prev);
      };

      const addNote = (note) => {
        const newNote = { ...note, id: generateId(), createdAt: new Date().toISOString() };
        setNotes(prev => [newNote, ...prev]);
        showToast('Note saved');
      };

      const deleteNote = (noteId) => {
        const noteToDelete = notes.find(n => n.id === noteId);
        if (!noteToDelete) return;

        setNotes(prev => prev.filter(n => n.id !== noteId));

        // Set up undo
        clearTimeout(undoTimeoutRef.current);
        setUndoData({ type: 'note', data: noteToDelete });
        setToast({ show: true, message: 'Note deleted', showUndo: true });

        // Auto-clear undo after 5 seconds
        undoTimeoutRef.current = setTimeout(() => {
          setUndoData(null);
          setToast({ show: false, message: '', showUndo: false });
        }, 5000);
      };

      const updateNote = (noteId, updatedText) => {
        setNotes(prev => prev.map(n =>
          n.id === noteId ? { ...n, text: updatedText } : n
        ));
        showToast('Note updated');
      };

      const handleUndo = () => {
        if (!undoData) return;

        clearTimeout(undoTimeoutRef.current);

        if (undoData.type === 'note') {
          setNotes(prev => [undoData.data, ...prev]);
          showToast('Note restored');
        } else if (undoData.type === 'source') {
          setSources(prev => [undoData.data.source, ...prev]);
          setNotes(prev => [...undoData.data.notes, ...prev]);
          showToast('Item restored');
        }

        setUndoData(null);
      };

      const navigateToNote = (note) => {
        setSidebarOpen(false);

        if (note.timestamp !== undefined) {
          // Video note - seek to timestamp
          setActiveTab('media');
          setTimeout(() => {
            if (mediaRef.current?.seekTo) {
              mediaRef.current.seekTo(note.timestamp);
            }
          }, 100);
        } else if (note.position !== undefined) {
          // Article/PDF note - go to sentence
          setActiveTab('reader');
          setTimeout(() => {
            if (readerRef.current?.navigateToSentence) {
              readerRef.current.navigateToSentence(note.position);
            }
          }, 100);
        }
      };

      const deleteSource = (sourceId) => {
        const sourceToDelete = sources.find(s => s.id === sourceId);
        if (!sourceToDelete) return;

        const relatedNotes = notes.filter(n => n.sourceId === sourceId);

        setSources(prev => prev.filter(s => s.id !== sourceId));
        setNotes(prev => prev.filter(n => n.sourceId !== sourceId));
        if (currentSource?.id === sourceId) {
          setCurrentSource(null);
        }

        // Set up undo
        clearTimeout(undoTimeoutRef.current);
        setUndoData({ type: 'source', data: { source: sourceToDelete, notes: relatedNotes } });
        setToast({ show: true, message: 'Item deleted from library', showUndo: true });

        // Auto-clear undo after 5 seconds
        undoTimeoutRef.current = setTimeout(() => {
          setUndoData(null);
          setToast({ show: false, message: '', showUndo: false });
        }, 5000);
      };

      const currentNotes = notes.filter(n => n.sourceId === currentSource?.id);

      // Determine if notes button should be enabled based on current tab and source type
      const isNotesAvailable = (() => {
        if (activeTab === 'library') return false;
        if (!currentSource) return false;
        if (activeTab === 'reader') {
          return currentSource.type === 'article' || currentSource.type === 'pdf';
        }
        if (activeTab === 'media') {
          return currentSource.type === 'youtube' || currentSource.type === 'podcast';
        }
        return false;
      })();

      return (
        <div className="app-container">
          <header className="header">
            <div className="logo">
              <div className="logo-icon">H</div>
              <div>
                <div className="logo-text">HarkenJot <span style={{ fontSize: '0.6rem', color: 'var(--text-muted)', fontWeight: 400 }}>v1.5.62</span></div>
                <div className="logo-tagline">Take Notes While You Listen</div>
              </div>
            </div>
            <nav className="nav-tabs">
              <button
                className={`nav-tab ${activeTab === 'reader' ? 'active' : ''}`}
                onClick={() => { setActiveTab('reader'); setCarMode(false); }}
              >
                <Icons.BookOpen /> Reader
              </button>
              <button
                className={`nav-tab ${activeTab === 'media' ? 'active' : ''}`}
                onClick={() => { setActiveTab('media'); setCarMode(false); }}
              >
                <Icons.Podcast /> Player
              </button>
              <button
                className={`nav-tab ${activeTab === 'library' ? 'active' : ''}`}
                onClick={() => { setActiveTab('library'); setCarMode(false); }}
              >
                <Icons.Library /> Library
              </button>
              <button
                className={`nav-tab notes-button ${sidebarOpen && isNotesAvailable ? 'active' : ''} ${!isNotesAvailable ? 'disabled' : ''}`}
                onClick={() => { if (isNotesAvailable) { setSidebarOpen(!sidebarOpen); setCarMode(false); }}}
                disabled={!isNotesAvailable}
                style={{ position: 'relative' }}
                title={!isNotesAvailable ? (activeTab === 'library' ? 'Notes not available in library view' : 'Load a source to view notes') : 'Toggle notes'}
              >
                <Icons.Pencil /> Notes
                {isNotesAvailable && currentNotes.length > 0 && (
                  <span style={{
                    position: 'absolute',
                    top: '2px',
                    right: '2px',
                    background: 'var(--accent)',
                    color: 'white',
                    fontSize: '0.6rem',
                    minWidth: '14px',
                    height: '14px',
                    borderRadius: '7px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}>{currentNotes.length}</span>
                )}
              </button>
            </nav>
          </header>

          <main className="main-content">
            <div className="content-area">
              {activeTab === 'reader' && (
                <ReaderView
                  ref={readerRef}
                  currentSource={currentSource}
                  setCurrentSource={setCurrentSource}
                  addSource={addSource}
                  addNote={addNote}
                  notes={currentNotes}
                  showToast={showToast}
                  carMode={carMode}
                  setCarMode={setCarMode}
                  isMobileDevice={isMobileDevice}
                />
              )}
              {activeTab === 'media' && (
                <MediaView
                  ref={mediaRef}
                  currentSource={currentSource}
                  setCurrentSource={setCurrentSource}
                  addSource={addSource}
                  updateSource={updateSource}
                  addNote={addNote}
                  notes={currentNotes}
                  showToast={showToast}
                  setActiveTab={setActiveTab}
                  carMode={carMode}
                  setCarMode={setCarMode}
                  isMobileDevice={isMobileDevice}
                />
              )}
              {activeTab === 'library' && (
                <LibraryView
                  sources={sources}
                  notes={notes}
                  setCurrentSource={(source) => {
                    setCurrentSource(source);
                    setActiveTab(source.type === 'youtube' || source.type === 'podcast' ? 'media' : 'reader');
                  }}
                  openSourceWithNotes={(source) => {
                    setCurrentSource(source);
                    setActiveTab(source.type === 'youtube' || source.type === 'podcast' ? 'media' : 'reader');
                    // Delay sidebar open to run after the useEffect that closes sidebar on tab change
                    setTimeout(() => setSidebarOpen(true), 0);
                  }}
                  deleteNote={deleteNote}
                  deleteSource={deleteSource}
                  setSources={setSources}
                  setNotes={setNotes}
                  showToast={showToast}
                />
              )}
            </div>

            <aside className={`sidebar ${sidebarOpen ? 'open' : ''}`}>
              <NoteSidebar
                notes={currentNotes}
                currentSource={currentSource}
                deleteNote={deleteNote}
                updateNote={updateNote}
                navigateToNote={navigateToNote}
                showToast={showToast}
                onClose={() => setSidebarOpen(false)}
              />
            </aside>
          </main>

          <Toast {...toast} onUndo={handleUndo} />
        </div>
      );
    }

    // Reader View Component
    const ReaderView = React.forwardRef(({ currentSource, setCurrentSource, addSource, addNote, notes, showToast, carMode, setCarMode, isMobileDevice }, ref) => {
      const [url, setUrl] = useState('');
      const [loading, setLoading] = useState(false);
      const [content, setContent] = useState(null);
      const [isPlaying, setIsPlaying] = useState(false);
      const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0);
      const [isRecording, setIsRecording] = useState(false);
      const [speed, setSpeed] = useState(1);
      const [manualContent, setManualContent] = useState('');
      const [showManualInput, setShowManualInput] = useState(false);
      const [showTextNote, setShowTextNote] = useState(false);
      const [textNote, setTextNote] = useState('');
      const [whisperReady, setWhisperReady] = useState(false);
      const [whisperLoading, setWhisperLoading] = useState(false);
      const [whisperProgress, setWhisperProgress] = useState(0);
      const [isTranscribing, setIsTranscribing] = useState(false);
      const [autoScroll, setAutoScroll] = useState(true);
      const [showSearch, setShowSearch] = useState(false);
      const [searchQuery, setSearchQuery] = useState('');
      const [searchResults, setSearchResults] = useState([]);

      const utteranceRef = useRef(null);
      const mediaRecorderRef = useRef(null);
      const audioChunksRef = useRef([]);
      const sentencesRef = useRef([]);
      const wasPlayingRef = useRef(false);
      const interruptedSentenceRef = useRef(0);
      const speakFromIndexRef = useRef(null);
      const lastBackPressRef = useRef(0);
      const wasCancelledRef = useRef(false);
      const wakeLockRef = useRef(null);
      const sentenceRefs = useRef({});
      const readerContainerRef = useRef(null);
      const isManualScrollingRef = useRef(false);
      const isStartingRecordingRef = useRef(false);

      // Expose navigation method to parent
      useImperativeHandle(ref, () => ({
        navigateToSentence: (index) => {
          setCurrentSentenceIndex(index);
          setAutoScroll(true);
          // Scroll to the sentence after a brief delay to ensure render
          setTimeout(() => {
            const sentenceElement = sentenceRefs.current[index];
            if (sentenceElement) {
              sentenceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 100);
        }
      }));

      // Load currentSource into content when source is selected from library
      useEffect(() => {
        if (currentSource && (currentSource.type === 'article' || currentSource.type === 'pdf')) {
          setContent({
            title: currentSource.title,
            sentences: currentSource.sentences,
            url: currentSource.url
          });
          setCurrentSentenceIndex(0);
          sentencesRef.current = currentSource.sentences;
        }
      }, [currentSource]);

      // Auto-scroll to current sentence when playing
      useEffect(() => {
        if (autoScroll && content) {
          const sentenceElement = sentenceRefs.current[currentSentenceIndex];
          if (sentenceElement) {
            isManualScrollingRef.current = false;
            sentenceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }
      }, [currentSentenceIndex, autoScroll, content]);

      // Detect manual scrolling to disable auto-scroll
      useEffect(() => {
        const container = readerContainerRef.current;
        if (!container) return;

        let scrollTimeout;
        const handleScroll = () => {
          // Only disable auto-scroll if this is a user-initiated scroll
          if (!isManualScrollingRef.current && autoScroll) {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
              setAutoScroll(false);
            }, 150);
          }
          isManualScrollingRef.current = false;
        };

        container.addEventListener('scroll', handleScroll, { passive: true });
        return () => {
          container.removeEventListener('scroll', handleScroll);
          clearTimeout(scrollTimeout);
        };
      }, [autoScroll]);

      // Skip to next sentence (stops current and plays next)
      const skipForward = () => {
        if (currentSentenceIndex < sentencesRef.current.length - 1) {
          setAutoScroll(true);
          wasCancelledRef.current = true;
          window.speechSynthesis.cancel();
          const nextIndex = currentSentenceIndex + 1;
          setCurrentSentenceIndex(nextIndex);
          if (isPlaying && speakFromIndexRef.current) {
            setTimeout(() => speakFromIndexRef.current(nextIndex), 50);
          }
        }
      };

      // Skip back - restart current sentence, or go to previous if pressed quickly
      const skipBack = () => {
        setAutoScroll(true);
        const now = Date.now();
        const timeSinceLastPress = now - lastBackPressRef.current;
        lastBackPressRef.current = now;

        wasCancelledRef.current = true;
        window.speechSynthesis.cancel();

        // If pressed within 1.5 seconds, go to previous sentence
        if (timeSinceLastPress < 1500 && currentSentenceIndex > 0) {
          const prevIndex = currentSentenceIndex - 1;
          setCurrentSentenceIndex(prevIndex);
          if (isPlaying && speakFromIndexRef.current) {
            setTimeout(() => speakFromIndexRef.current(prevIndex), 50);
          }
        } else {
          // Restart current sentence
          if (isPlaying && speakFromIndexRef.current) {
            setTimeout(() => speakFromIndexRef.current(currentSentenceIndex), 50);
          }
        }
      };

      // Search functionality
      const handleSearch = (query) => {
        setSearchQuery(query);
        if (!query.trim() || !content) {
          setSearchResults([]);
          return;
        }

        const results = [];
        const lowerQuery = query.toLowerCase();
        sentencesRef.current.forEach((sentence, index) => {
          if (sentence.toLowerCase().includes(lowerQuery)) {
            results.push({ index, sentence });
          }
        });
        setSearchResults(results);
      };

      const navigateToSearchResult = (index) => {
        setCurrentSentenceIndex(index);
        setAutoScroll(true);
        setShowSearch(false);
        setTimeout(() => {
          const sentenceElement = sentenceRefs.current[index];
          if (sentenceElement) {
            sentenceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }, 100);
      };

      // Load Whisper model on mount
      useEffect(() => {
        let attempts = 0;
        const maxAttempts = 10;

        const loadWhisper = async () => {
          console.log('Attempting to load Whisper, attempt:', attempts + 1);

          // Wait for WhisperASR to be available from the module
          if (!window.WhisperASR) {
            attempts++;
            if (attempts < maxAttempts) {
              console.log('WhisperASR not yet available, retrying...');
              setTimeout(loadWhisper, 500);
            } else {
              console.error('WhisperASR failed to initialize');
              showToast('Speech recognition unavailable. Use text notes.');
            }
            return;
          }

          if (window.WhisperASR.isReady) {
            setWhisperReady(true);
            return;
          }

          if (window.WhisperASR.isLoading) {
            return;
          }

          setWhisperLoading(true);
          showToast('Loading speech recognition model (first time only)...');

          try {
            const success = await window.WhisperASR.loadModel((progress) => {
              setWhisperProgress(progress);
            });
            setWhisperLoading(false);
            if (success) {
              setWhisperReady(true);
              showToast('Speech recognition ready!');
            } else {
              showToast('Failed to load speech model. You can still use text notes.');
            }
          } catch (error) {
            console.error('Error loading Whisper:', error);
            setWhisperLoading(false);
            showToast('Speech recognition failed to load. Use text notes.');
          }
        };

        // Start loading after a short delay
        const timer = setTimeout(loadWhisper, 500);
        return () => clearTimeout(timer);
      }, []);

      // Load source content and saved position when currentSource changes
      useEffect(() => {
        if (currentSource && (currentSource.type === 'article' || currentSource.type === 'pdf') && currentSource.content) {
          setContent({
            title: currentSource.title,
            sentences: currentSource.sentences || splitIntoSentences(currentSource.content),
            url: currentSource.url
          });
          sentencesRef.current = currentSource.sentences || splitIntoSentences(currentSource.content);

          // Load saved position for this source
          const savedPositions = JSON.parse(localStorage.getItem('harkenjot_positions') || '{}');
          const savedPosition = savedPositions[currentSource.id];
          if (savedPosition !== undefined && savedPosition < sentencesRef.current.length) {
            setCurrentSentenceIndex(savedPosition);
          } else {
            setCurrentSentenceIndex(0);
          }
        }
      }, [currentSource]);

      // Save position whenever it changes
      useEffect(() => {
        if (currentSource?.id && content) {
          const savedPositions = JSON.parse(localStorage.getItem('harkenjot_positions') || '{}');
          savedPositions[currentSource.id] = currentSentenceIndex;
          localStorage.setItem('harkenjot_positions', JSON.stringify(savedPositions));
        }
      }, [currentSentenceIndex, currentSource?.id, content]);

      // Track isPlaying in a ref for event handlers
      const isPlayingRef = useRef(false);
      useEffect(() => {
        isPlayingRef.current = isPlaying;
      }, [isPlaying]);

      // Pause and save when page becomes hidden (browser tab switch or app close)
      useEffect(() => {
        const handleVisibilityChange = () => {
          if (document.hidden && isPlayingRef.current) {
            wasCancelledRef.current = true;
            window.speechSynthesis.cancel();
            setIsPlaying(false);
            showToast('Playback paused - position saved');
          }
        };

        const handleBeforeUnload = () => {
          if (isPlayingRef.current) {
            window.speechSynthesis.cancel();
          }
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('beforeunload', handleBeforeUnload);

        return () => {
          document.removeEventListener('visibilitychange', handleVisibilityChange);
          window.removeEventListener('beforeunload', handleBeforeUnload);
        };
      }, [showToast]);

      const splitIntoSentences = (text) => {
        return text.match(/[^.!?]+[.!?]+/g) || [text];
      };

      const extractArticleContent = (html) => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        // Remove unwanted elements
        const removeSelectors = ['script', 'style', 'nav', 'header', 'footer', 'aside', 'iframe', 'noscript', '.ad', '.advertisement', '.sidebar', '.menu', '.navigation', '.comment', '.comments'];
        removeSelectors.forEach(selector => {
          doc.querySelectorAll(selector).forEach(el => el.remove());
        });

        // Get the title
        const title = doc.querySelector('title')?.textContent ||
                      doc.querySelector('h1')?.textContent ||
                      doc.querySelector('meta[property="og:title"]')?.content ||
                      'Untitled Article';

        // Try to find main content in order of preference
        const contentSelectors = [
          'article',
          '[role="main"]',
          'main',
          '.article-content',
          '.post-content',
          '.entry-content',
          '.content',
          '.article-body',
          '.story-body',
          '#content',
          '#article'
        ];

        let contentElement = null;
        for (const selector of contentSelectors) {
          contentElement = doc.querySelector(selector);
          if (contentElement) break;
        }

        // Fall back to body if no specific content area found
        if (!contentElement) {
          contentElement = doc.body;
        }

        // Extract text from paragraphs for cleaner content
        const paragraphs = contentElement.querySelectorAll('p');
        let text = '';

        if (paragraphs.length > 3) {
          // If we have paragraphs, use them for cleaner extraction
          paragraphs.forEach(p => {
            const pText = p.textContent.trim();
            if (pText.length > 20) { // Filter out short paragraphs (likely UI elements)
              text += pText + ' ';
            }
          });
        } else {
          // Fall back to all text content
          text = contentElement.textContent;
        }

        // Clean up the text
        text = text
          .replace(/\s+/g, ' ')           // Collapse whitespace
          .replace(/\n+/g, ' ')           // Remove newlines
          .replace(/\t+/g, ' ')           // Remove tabs
          .trim();

        return { title: title.trim(), text };
      };

      const fetchContent = async () => {
        if (!url.trim()) return;

        setLoading(true);

        try {
          // Check if it's a PDF
          if (url.toLowerCase().endsWith('.pdf') || url.toLowerCase().includes('.pdf')) {
            try {
              pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
              showToast('Loading PDF...');

              // Fetch PDF as binary data - try multiple methods
              let pdfData;
              const corsProxies = [
                (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`,
                (u) => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
                (u) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`,
              ];

              // Try direct fetch first
              try {
                console.log('Trying direct PDF fetch...');
                const response = await fetch(url, { mode: 'cors' });
                if (response.ok) {
                  pdfData = await response.arrayBuffer();
                  console.log('Direct fetch succeeded');
                }
              } catch (e) {
                console.log('Direct fetch failed:', e.message);
              }

              // Try proxies if direct failed
              if (!pdfData) {
                for (const proxyFn of corsProxies) {
                  try {
                    const proxyUrl = proxyFn(url);
                    console.log('Trying proxy:', proxyUrl);
                    const response = await fetch(proxyUrl);
                    if (response.ok) {
                      pdfData = await response.arrayBuffer();
                      console.log('Proxy fetch succeeded:', pdfData.byteLength, 'bytes');
                      break;
                    }
                  } catch (e) {
                    console.log('Proxy failed:', e.message);
                  }
                }
              }

              if (!pdfData) {
                throw new Error('All fetch methods failed');
              }

              console.log('PDF data loaded:', pdfData.byteLength, 'bytes');

              // Load PDF from binary data
              const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
              console.log('PDF parsed:', pdf.numPages, 'pages');

              let fullText = '';
              for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += pageText + ' ';
              }

              if (!fullText.trim()) {
                showToast('PDF has no readable text. It may be scanned/image-based.');
                setShowManualInput(true);
                setLoading(false);
                return;
              }

              const sentences = splitIntoSentences(fullText);
              sentencesRef.current = sentences;

              const newSource = addSource({
                type: 'pdf',
                title: url.split('/').pop()?.replace('.pdf', '') || 'PDF Document',
                url: url,
                content: fullText,
                sentences: sentences
              });

              setContent({
                title: newSource.title,
                sentences: sentences,
                url: url
              });
              setUrl(''); // Clear URL after successful load
              showToast('PDF loaded successfully!');
              setLoading(false);
              return;
            } catch (error) {
              console.error('PDF fetch error:', error);
              showToast('Could not load PDF. Try pasting content manually.');
              setShowManualInput(true);
              setLoading(false);
              return;
            }
          }

          // For web articles, try multiple CORS proxies
          showToast('Fetching article content...');

          const corsProxies = [
            {
              name: 'allorigins',
              url: (u) => `https://api.allorigins.win/get?url=${encodeURIComponent(u)}`,
              extract: (data) => data.contents
            },
            {
              name: 'corsproxy.io',
              url: (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`,
              extract: (data) => data
            },
            {
              name: 'codetabs',
              url: (u) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`,
              extract: (data) => data
            }
          ];

          let html = null;
          let lastError = null;

          for (const proxy of corsProxies) {
            try {
              console.log(`Trying ${proxy.name} proxy...`);
              const proxyUrl = proxy.url(url);
              const response = await fetch(proxyUrl);

              if (!response.ok) {
                throw new Error(`${proxy.name} returned ${response.status}`);
              }

              const data = await (proxy.name === 'allorigins' ? response.json() : response.text());
              html = proxy.extract(data);

              if (html && html.length > 100) {
                console.log(`${proxy.name} succeeded`);
                break;
              }
            } catch (error) {
              console.log(`${proxy.name} failed:`, error.message);
              lastError = error;
            }
          }

          if (!html) {
            throw lastError || new Error('All proxies failed');
          }

          const { title, text } = extractArticleContent(html);

          if (text.length < 100) {
            showToast('Could not extract enough content. Try pasting manually.');
            setShowManualInput(true);
            setLoading(false);
            return;
          }

          const sentences = splitIntoSentences(text);
          sentencesRef.current = sentences;

          const newSource = addSource({
            type: 'article',
            title: title,
            url: url,
            content: text,
            sentences: sentences
          });

          setContent({
            title: newSource.title,
            sentences: sentences,
            url: url
          });

          setUrl(''); // Clear URL after successful load
          showToast('Article loaded successfully!');

        } catch (error) {
          console.error('Fetch error:', error);
          showToast('Could not fetch content. Try pasting manually.');
          setShowManualInput(true);
        }

        setLoading(false);
      };

      const handleManualSubmit = () => {
        if (!manualContent.trim()) return;
        
        const sentences = splitIntoSentences(manualContent);
        sentencesRef.current = sentences;
        
        const newSource = addSource({
          type: 'article',
          title: url || 'Pasted Content',
          url: url || null,
          content: manualContent,
          sentences: sentences
        });
        
        setContent({
          title: newSource.title,
          sentences: sentences,
          url: url
        });

        setUrl(''); // Clear URL after successful load
        setShowManualInput(false);
        setManualContent('');
      };

      // Wake Lock helpers to keep screen on during playback
      const requestWakeLock = async () => {
        try {
          if ('wakeLock' in navigator) {
            // Release old wake lock if it exists
            if (wakeLockRef.current) {
              try {
                await wakeLockRef.current.release();
              } catch (e) {
                // Ignore errors from releasing
              }
            }

            // Always request fresh wake lock (handles screen on/off cycles)
            wakeLockRef.current = await navigator.wakeLock.request('screen');
            console.log('Wake Lock activated');

            // Listen for release event to clear the ref
            wakeLockRef.current.addEventListener('release', () => {
              console.log('Wake Lock was released');
              wakeLockRef.current = null;
            });
          }
        } catch (err) {
          console.log('Wake Lock not supported or failed:', err);
          wakeLockRef.current = null;
        }
      };

      const releaseWakeLock = async () => {
        try {
          if (wakeLockRef.current) {
            await wakeLockRef.current.release();
            wakeLockRef.current = null;
            console.log('Wake Lock released');
          }
        } catch (err) {
          console.log('Wake Lock release failed:', err);
        }
      };

      const togglePlayback = () => {
        if (isPlaying) {
          wasCancelledRef.current = true;
          window.speechSynthesis.cancel();
          setIsPlaying(false);
          releaseWakeLock();
        } else {
          setAutoScroll(true);
          speakFromIndex(currentSentenceIndex);
        }
      };

      // Get best available voice (prioritize Google, then Microsoft)
      const getBestVoice = () => {
        const voices = window.speechSynthesis.getVoices();
        if (!voices.length) return null;

        // Filter for English voices only
        const englishVoices = voices.filter(voice => voice.lang.startsWith('en'));

        // Prioritize Google voices
        const googleVoice = englishVoices.find(voice => voice.name.includes('Google'));
        if (googleVoice) return googleVoice;

        // Then Microsoft voices (prefer ones with "Online" or newer versions)
        const microsoftVoice = englishVoices.find(voice =>
          voice.name.includes('Microsoft') &&
          (voice.name.includes('Online') || voice.name.includes('Natural'))
        );
        if (microsoftVoice) return microsoftVoice;

        // Fall back to any Microsoft voice
        const anyMicrosoftVoice = englishVoices.find(voice => voice.name.includes('Microsoft'));
        if (anyMicrosoftVoice) return anyMicrosoftVoice;

        // Fall back to first English voice
        return englishVoices[0] || voices[0];
      };

      const speakFromIndex = useCallback((index) => {
        if (!content || index >= content.sentences.length) {
          setIsPlaying(false);
          releaseWakeLock();
          return;
        }

        wasCancelledRef.current = false;
        setIsPlaying(true);
        requestWakeLock(); // Keep screen on during playback
        setCurrentSentenceIndex(index);
        const utterance = new SpeechSynthesisUtterance(content.sentences[index]);
        utterance.rate = speed;

        // Set best available voice
        const bestVoice = getBestVoice();
        if (bestVoice) {
          utterance.voice = bestVoice;
        }

        utterance.onend = () => {
          // Don't continue if speech was intentionally cancelled
          if (wasCancelledRef.current) {
            wasCancelledRef.current = false;
            releaseWakeLock();
            return;
          }
          const nextIndex = index + 1;
          setCurrentSentenceIndex(nextIndex);
          if (nextIndex < content.sentences.length && speakFromIndexRef.current) {
            speakFromIndexRef.current(nextIndex);
          } else {
            setIsPlaying(false);
            releaseWakeLock(); // Release when playback ends
          }
        };

        utteranceRef.current = utterance;
        window.speechSynthesis.speak(utterance);
      }, [content, speed]);

      // Keep the ref updated with the latest speakFromIndex function
      useEffect(() => {
        speakFromIndexRef.current = speakFromIndex;
      }, [speakFromIndex]);

      // Apply speed changes immediately while playing
      const prevSpeedRef = useRef(speed);
      useEffect(() => {
        if (prevSpeedRef.current !== speed && isPlaying && speakFromIndexRef.current) {
          // Cancel current speech and restart from current sentence with new speed
          wasCancelledRef.current = true;
          window.speechSynthesis.cancel();
          // Small delay to ensure cancel completes before restarting
          setTimeout(() => {
            speakFromIndexRef.current(currentSentenceIndex);
          }, 50);
        }
        prevSpeedRef.current = speed;
      }, [speed, isPlaying, currentSentenceIndex]);

      const streamRef = useRef(null);
      const audioContextRef = useRef(null);
      const analyzerRef = useRef(null);
      const silenceTimeoutRef = useRef(null);
      const isProcessing = isRecording || isTranscribing;

      const stopRecording = () => {
        if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
          playSound('stop');
          mediaRecorderRef.current.stop();
        }

        // Clean up audio context
        if (audioContextRef.current) {
          try {
            audioContextRef.current.close();
          } catch (err) {
            console.log('Error closing audio context:', err);
          }
          audioContextRef.current = null;
        }

        // Clean up stream
        if (streamRef.current) {
          streamRef.current.getTracks().forEach(track => track.stop());
          streamRef.current = null;
        }

        // Clear silence timeout
        if (silenceTimeoutRef.current) {
          clearTimeout(silenceTimeoutRef.current);
          silenceTimeoutRef.current = null;
        }
      };

      const handleVoiceButtonClick = () => {
        if (isRecording) {
          stopRecording();
        } else if (isTranscribing) {
          // Provide feedback that we're busy transcribing
          playSound('error');
          showToast('Still processing previous recording...');
        } else if (isStartingRecordingRef.current) {
          // Prevent concurrent startRecording calls
          playSound('error');
          showToast('Please wait, starting recording...');
        } else {
          startRecording();
        }
      };

      const startRecording = async () => {
        if (!whisperReady) {
          playSound('error');
          showToast('Speech recognition still loading. Please wait or use text notes.');
          return;
        }

        // Prevent race condition from multiple rapid clicks
        if (isStartingRecordingRef.current) {
          return;
        }
        isStartingRecordingRef.current = true;

        // Clean up any existing recording state
        stopRecording();

        // Store state before stopping playback (use local vars, not refs)
        const wasPlaying = isPlaying;
        const notePosition = currentSentenceIndex;

        if (isPlaying) {
          wasCancelledRef.current = true;
          window.speechSynthesis.cancel();
          setIsPlaying(false);
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          streamRef.current = stream;

          const mimeType = window.WhisperASR?.getSupportedMimeType() || '';
          const mediaRecorder = mimeType
            ? new MediaRecorder(stream, { mimeType })
            : new MediaRecorder(stream);
          mediaRecorderRef.current = mediaRecorder;

          // Use local array to avoid ref timing issues
          const audioChunks = [];

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunks.push(event.data);
            }
          };

          mediaRecorder.onerror = (event) => {
            console.error('MediaRecorder error:', event.error);
            showToast('Recording error. Try again.');
            stream.getTracks().forEach(track => track.stop());
            setIsRecording(false);
          };

          mediaRecorder.onstop = async () => {
            // Clean up audio context and timers
            if (audioContextRef.current) {
              audioContextRef.current.close();
              audioContextRef.current = null;
            }
            if (silenceTimeoutRef.current) {
              clearTimeout(silenceTimeoutRef.current);
              silenceTimeoutRef.current = null;
            }

            // Stop all tracks
            stream.getTracks().forEach(track => track.stop());
            streamRef.current = null;

            if (audioChunks.length === 0) {
              playSound('error');
              showToast('No audio captured. Try again.');
              setIsRecording(false);
              if (wasPlaying && speakFromIndexRef.current) {
                setTimeout(() => speakFromIndexRef.current(notePosition), 300);
              }
              return;
            }

            const audioBlob = new Blob(audioChunks, { type: mimeType || 'audio/webm' });

            if (audioBlob.size < 500) {
              playSound('error');
              showToast('Recording too short. Try again.');
              setIsRecording(false);
              if (wasPlaying && speakFromIndexRef.current) {
                setTimeout(() => speakFromIndexRef.current(notePosition), 300);
              }
              return;
            }

            // Transition from recording to transcribing
            setIsRecording(false);
            setIsTranscribing(true);

            try {
              const transcript = await window.WhisperASR.transcribe(audioBlob);
              if (transcript && transcript.trim()) {
                const sentence = sentencesRef.current[notePosition];
                addNote({
                  sourceId: currentSource?.id,
                  text: transcript.trim(),
                  position: notePosition,
                  context: sentence?.substring(0, 100) + '...',
                  type: 'voice'
                });
                playSound('success');
                showToast('Note saved!');
              } else {
                playSound('error');
                showToast('No speech detected - try speaking louder');
              }
            } catch (error) {
              console.error('Transcription failed:', error);
              playSound('error');
              showToast('Transcription failed. Try again.');
            }
            setIsTranscribing(false);

            // Resume playback if it was playing before
            if (wasPlaying && speakFromIndexRef.current) {
              setTimeout(() => speakFromIndexRef.current(notePosition), 300);
            }
          };

          // Start with timeslice for more reliable data capture
          mediaRecorder.start(100);
          setIsRecording(true);
          isStartingRecordingRef.current = false; // Recording started successfully
          playSound('start');
          showToast('Listening...');

            // Set up voice activity detection for auto-stop
            try {
              const audioContext = new (window.AudioContext || window.webkitAudioContext)();
              audioContextRef.current = audioContext;

              const source = audioContext.createMediaStreamSource(stream);
              const analyzer = audioContext.createAnalyser();
              analyzer.fftSize = 2048;
              analyzer.smoothingTimeConstant = 0.8;
              source.connect(analyzer);
              analyzerRef.current = analyzer;

              const dataArray = new Uint8Array(analyzer.frequencyBinCount);
              const frequencyData = new Uint8Array(analyzer.frequencyBinCount);
              const recordingStartTime = Date.now();
              let lastSoundTime = Date.now();
              let gracePeriodEnded = false;
              const SILENCE_DURATION = 2500; // 2.5 seconds of silence before auto-stop
              const GRACE_PERIOD = 2000; // 2 seconds grace period before checking for silence

              const checkAudioLevel = () => {
                if (!mediaRecorderRef.current || mediaRecorderRef.current.state !== 'recording') {
                  return;
                }

                const elapsed = Date.now() - recordingStartTime;
                const inGracePeriod = elapsed < GRACE_PERIOD;

                // Reset lastSoundTime when grace period ends (only once)
                if (!inGracePeriod && !gracePeriodEnded) {
                  lastSoundTime = Date.now();
                  gracePeriodEnded = true;
                }

                // Get frequency data for voice detection
                analyzer.getByteFrequencyData(frequencyData);

                // Voice typically exists in 85Hz - 4000Hz range
                // Calculate which frequency bins correspond to this range
                const sampleRate = audioContext.sampleRate;
                const binCount = analyzer.frequencyBinCount;
                const binSize = sampleRate / (binCount * 2);

                const voiceStartBin = Math.floor(85 / binSize);
                const voiceEndBin = Math.floor(4000 / binSize);

                // Calculate average energy in voice frequency range
                let voiceEnergy = 0;
                let voiceBinCount = 0;
                for (let i = voiceStartBin; i < voiceEndBin && i < binCount; i++) {
                  voiceEnergy += frequencyData[i];
                  voiceBinCount++;
                }
                const avgVoiceEnergy = voiceBinCount > 0 ? voiceEnergy / voiceBinCount : 0;

                // Also check overall amplitude for additional confidence
                analyzer.getByteTimeDomainData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                  const amplitude = Math.abs(dataArray[i] - 128);
                  sum += amplitude;
                }
                const avgAmplitude = sum / dataArray.length;

                // Voice detected if there's energy in voice frequencies AND sufficient amplitude
                // These thresholds are more Google-like: higher and more selective
                const VOICE_ENERGY_THRESHOLD = 30; // Energy in voice frequency range (0-255)
                const AMPLITUDE_THRESHOLD = 8; // Overall amplitude (0-127)

                const isVoiceDetected = avgVoiceEnergy > VOICE_ENERGY_THRESHOLD && avgAmplitude > AMPLITUDE_THRESHOLD;

                // If voice detected, reset silence timer
                if (isVoiceDetected) {
                  lastSoundTime = Date.now();
                  if (silenceTimeoutRef.current) {
                    clearTimeout(silenceTimeoutRef.current);
                    silenceTimeoutRef.current = null;
                  }
                } else if (!inGracePeriod) {
                  // Only check for auto-stop AFTER grace period
                  const silenceDuration = Date.now() - lastSoundTime;
                  if (silenceDuration > SILENCE_DURATION && !silenceTimeoutRef.current) {
                    // Auto-stop recording after silence
                    console.log('Auto-stopping recording after silence');
                    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                      setIsRecording(false);
                      mediaRecorderRef.current.stop();
                    }
                    if (audioContextRef.current) {
                      audioContextRef.current.close();
                      audioContextRef.current = null;
                    }
                    return; // Stop checking
                  }
                }

                // Continue checking
                requestAnimationFrame(checkAudioLevel);
              };

              // Start monitoring audio levels
              checkAudioLevel();
            } catch (err) {
              console.log('Voice activity detection setup failed:', err);
              // Continue recording without auto-stop if VAD fails
            }
          } catch (error) {
            console.error('Failed to start recording:', error);
            playSound('error');
            showToast('Microphone access denied or unavailable');
            setIsRecording(false);
            isStartingRecordingRef.current = false; // Failed to start
            // Clean up any partial setup
            if (audioContextRef.current) {
              try {
                audioContextRef.current.close();
              } catch (err) {}
              audioContextRef.current = null;
            }
            if (streamRef.current) {
              streamRef.current.getTracks().forEach(track => track.stop());
              streamRef.current = null;
            }
          }
      };

      const saveTextNote = () => {
        if (textNote.trim()) {
          const sentence = sentencesRef.current[currentSentenceIndex];
          addNote({
            sourceId: currentSource?.id,
            text: textNote.trim(),
            position: currentSentenceIndex,
            context: sentence?.substring(0, 100) + '...',
            type: 'text'
          });
          setTextNote('');
          setShowTextNote(false);
        }

        // Resume playback if it was playing before
        if (wasPlayingRef.current && speakFromIndexRef.current) {
          setTimeout(() => speakFromIndexRef.current(currentSentenceIndex), 100);
          wasPlayingRef.current = false;
        }
      };

      const cancelTextNote = () => {
        setShowTextNote(false);
        setTextNote('');

        // Resume playback if it was playing before
        if (wasPlayingRef.current && speakFromIndexRef.current) {
          setTimeout(() => speakFromIndexRef.current(currentSentenceIndex), 100);
          wasPlayingRef.current = false;
        }
      };

      const openTextNote = () => {
        // Store playback state and pause if playing
        if (isPlaying) {
          wasPlayingRef.current = true;
          wasCancelledRef.current = true;
          window.speechSynthesis.cancel();
          setIsPlaying(false);
        } else {
          wasPlayingRef.current = false;
        }
        setShowTextNote(true);
      };

      const progress = content ? (currentSentenceIndex / content.sentences.length) * 100 : 0;
      const notedSentences = new Set(notes.map(n => n.position));

      return (
        <div style={{ display: 'flex', flexDirection: 'column', flex: 1, minHeight: 0, overflow: 'hidden' }}>
          <div className="input-section" style={{ display: carMode ? 'none' : 'block' }}>
            <div className="input-group">
              <input
                type="text"
                className="url-input"
                placeholder="Paste article or PDF link..."
                value={url}
                onChange={(e) => setUrl(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && fetchContent()}
              />
              <button className="btn btn-primary" onClick={fetchContent} disabled={loading}>
                {loading ? 'Loading...' : <><Icons.Link /> Load</>}
              </button>
            </div>

            {showManualInput && (
              <div style={{ marginTop: '0.5rem' }}>
                <textarea
                  className="url-input"
                  style={{ width: '100%', minHeight: '100px', resize: 'vertical' }}
                  placeholder="Paste article content here..."
                  value={manualContent}
                  onChange={(e) => setManualContent(e.target.value)}
                />
                <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem' }}>
                  <button className="btn btn-primary" onClick={handleManualSubmit}>
                    <Icons.Plus /> Add to Library
                  </button>
                  <button className="btn btn-secondary" onClick={() => setShowManualInput(false)}>
                    Cancel
                  </button>
                </div>
              </div>
            )}
          </div>

          {content ? (
            <div className="reader-container">
              <div className="reader-header">
                <div className="source-info">
                  <h2>{content.title}</h2>
                  <div className="source-meta">
                    <span className={`library-item-type ${currentSource?.type || 'article'}`}>{currentSource?.type || 'Article'}</span>
                    {content.url && <span style={{ maxWidth: '200px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{new URL(content.url).hostname}</span>}
                    <span>{content.sentences.length} sentences</span>
                    {content.url && <a href={content.url} target="_blank" rel="noopener noreferrer"><Icons.Link /></a>}
                  </div>
                </div>
              </div>
              
              <div className="reader-body" ref={readerContainerRef} style={{ display: carMode ? 'none' : 'block' }}>
                <div className="reader-content">
                  {content.sentences.map((sentence, index) => (
                    <span
                      key={index}
                      ref={(el) => sentenceRefs.current[index] = el}
                      className={`sentence ${index === currentSentenceIndex ? 'current' : ''} ${notedSentences.has(index) ? 'has-note' : ''}`}
                      onClick={() => setCurrentSentenceIndex(index)}
                    >
                      {sentence}{' '}
                    </span>
                  ))}
                </div>
              </div>
              
              {showTextNote && (
                <div className="text-note-container">
                  <input
                    type="text"
                    className="url-input text-note-input"
                    placeholder="Type your note..."
                    value={textNote}
                    onChange={(e) => setTextNote(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && saveTextNote()}
                    autoFocus
                  />
                  <div className="text-note-buttons">
                    <button className="btn btn-primary" onClick={saveTextNote}>Save</button>
                    <button className="btn btn-secondary" onClick={cancelTextNote}>Cancel</button>
                  </div>
                </div>
              )}

              {showSearch && (
                <div className="search-container">
                  <input
                    type="text"
                    className="url-input"
                    placeholder="Search in text..."
                    value={searchQuery}
                    onChange={(e) => handleSearch(e.target.value)}
                    autoFocus
                  />
                  <button className="btn btn-secondary" onClick={() => setShowSearch(false)}>Close</button>
                  {searchResults.length > 0 && (
                    <div className="search-results">
                      <div style={{ fontSize: '0.875rem', fontWeight: 500, marginBottom: '0.5rem' }}>
                        {searchResults.length} result{searchResults.length !== 1 ? 's' : ''}
                      </div>
                      {searchResults.map((result, idx) => (
                        <div
                          key={idx}
                          className="search-result-item"
                          onClick={() => navigateToSearchResult(result.index)}
                        >
                          <div style={{ fontSize: '0.75rem', color: 'var(--accent)', fontWeight: 500 }}>
                            Sentence {result.index + 1}
                          </div>
                          <div style={{ fontSize: '0.875rem' }}>
                            {result.sentence.substring(0, 150)}{result.sentence.length > 150 ? '...' : ''}
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                  {searchQuery && searchResults.length === 0 && (
                    <div style={{ padding: '1rem', textAlign: 'center', color: 'var(--text-muted)', fontSize: '0.875rem' }}>
                      No results found
                    </div>
                  )}
                </div>
              )}
              <div className={`playback-bar ${carMode ? 'car-mode' : ''}`}>
                <div className="playback-controls">
                  <div className="transport-buttons">
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={skipBack}
                      title="Restart sentence / Previous (double-tap)"
                    >
                      <Icons.SkipBack />
                    </button>
                    <button className={`play-btn ${carMode ? 'car-mode' : ''}`} onClick={togglePlayback}>
                      {isPlaying ? <Icons.Pause /> : <Icons.Play />}
                    </button>
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={skipForward}
                      disabled={currentSentenceIndex === content.sentences.length - 1}
                      title="Next sentence"
                    >
                      <Icons.SkipForward />
                    </button>
                  </div>

                  <div className={`progress-speed-group ${carMode ? 'car-mode' : ''}`}>
                    <div className="progress-container">
                      <div className={`progress-bar ${carMode ? 'car-mode' : ''}`}>
                        <div className="progress-fill" style={{ width: `${progress}%` }} />
                      </div>
                      <div className="progress-text">
                        <span>Sentence {currentSentenceIndex + 1} of {content.sentences.length}</span>
                        <span>{Math.round(progress)}%</span>
                      </div>
                    </div>

                    <div className={`speed-control ${carMode ? 'car-mode' : ''}`}>
                      <label>Speed</label>
                      <select value={speed} onChange={(e) => setSpeed(parseFloat(e.target.value))}>
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1">1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                      </select>
                    </div>
                  </div>
                </div>

                <div className="note-controls">
                  <button
                    className={`note-btn ${isProcessing ? 'processing' : ''} ${carMode ? 'car-mode' : ''}`}
                    onClick={handleVoiceButtonClick}
                    disabled={whisperLoading}
                  >
                    {whisperLoading ? `Loading ${whisperProgress}%` :
                     isRecording ? ' Stop' :
                     isTranscribing ? 'Processing...' :
                     <><Icons.Mic /> Voice</>}
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    onClick={openTextNote}
                  >
                    <Icons.Keyboard /> Type
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    onClick={() => setShowSearch(!showSearch)}
                  >
                    <Icons.Search /> Search
                  </button>
                  {isMobileDevice && (
                    <button
                      className={`note-btn ${carMode ? 'car-mode active' : ''}`}
                      onClick={() => setCarMode(!carMode)}
                      title="Car Mode"
                    >
                      <Icons.Car />
                    </button>
                  )}
                </div>
              </div>
            </div>
          ) : (
            <div className="empty-state">
              <div className="empty-state-icon"></div>
              <h3>Article Reader</h3>
              <p>Paste an article or PDF link above to begin. The app will read it aloud and let you take notes while you listen.</p>
            </div>
          )}
        </div>
      );
    });

    // Media View Component
    const MediaView = React.forwardRef(({ currentSource, setCurrentSource, addSource, updateSource, addNote, notes, showToast, setActiveTab, carMode, setCarMode, isMobileDevice }, ref) => {
      const [url, setUrl] = useState('');
      const [isPlaying, setIsPlaying] = useState(false);
      const [currentTime, setCurrentTime] = useState(0);
      const [duration, setDuration] = useState(0);
      const [isRecording, setIsRecording] = useState(false);
      const [videoId, setVideoId] = useState(null);
      const [podcastAudio, setPodcastAudio] = useState(null); // { audioUrl, title, showName, artworkUrl, link }
      const [isLoadingPodcast, setIsLoadingPodcast] = useState(false);
      const [whisperReady, setWhisperReady] = useState(false);
      const [isTranscribing, setIsTranscribing] = useState(false);
      const [showTextNote, setShowTextNote] = useState(false);
      const [textNote, setTextNote] = useState('');
      const [speed, setSpeed] = useState(1);

      const playerRef = useRef(null);
      const audioPlayerRef = useRef(null); // HTML5 audio element for podcasts
      const mediaRecorderRef = useRef(null);
      const audioChunksRef = useRef([]);
      const intervalRef = useRef(null);
      const isStartingRecordingRef = useRef(false);
      const lastInitializedSourceRef = useRef(null); // Track last initialized source to prevent re-init loops
      const wasPlayingRef = useRef(false);

      // Expose seekTo method to parent
      useImperativeHandle(ref, () => ({
        seekTo: (timestamp) => {
          if (playerRef.current) {
            playerRef.current.seekTo(timestamp, true);
          } else if (audioPlayerRef.current) {
            audioPlayerRef.current.currentTime = timestamp;
          }
        }
      }));
      const wakeLockRef = useRef(null);
      const audioContextRef = useRef(null);
      const analyzerRef = useRef(null);
      const silenceTimeoutRef = useRef(null);
      const isProcessing = isRecording || isTranscribing;

      // Load currentSource into player when source is selected from library
      useEffect(() => {
        if (currentSource && currentSource.type === 'youtube' && currentSource.videoId) {
          // Skip if we already initialized for this source (prevents loop when updateSource updates currentSource)
          if (lastInitializedSourceRef.current === currentSource.id) {
            return;
          }
          lastInitializedSourceRef.current = currentSource.id;

          setVideoId(currentSource.videoId);
          setPodcastAudio(null);
          // Don't set URL - keep input clear after loading
          // Initialize player after state update
          setTimeout(() => {
            if (window.YT && window.YT.Player) {
              initPlayer(currentSource.videoId);
              // Restore saved position after player is ready (without auto-playing)
              setTimeout(() => {
                if (playerRef.current) {
                  const savedPositions = JSON.parse(localStorage.getItem('harkenjot_media_positions') || '{}');
                  const savedPosition = savedPositions[currentSource.id];
                  if (savedPosition) {
                    playerRef.current.seekTo(savedPosition, true);
                    playerRef.current.pauseVideo(); // Don't auto-play, just cue up
                    setCurrentTime(savedPosition); // Update progress bar immediately
                  }
                }
              }, 500);
            }
          }, 100);
        } else if (currentSource && currentSource.type === 'podcast' && currentSource.audioUrl) {
          // Skip if we already initialized for this source (prevents loop when updateSource updates currentSource)
          if (lastInitializedSourceRef.current === currentSource.id) {
            return;
          }
          lastInitializedSourceRef.current = currentSource.id;

          setVideoId(null);
          setPodcastAudio({
            audioUrl: currentSource.audioUrl,
            title: currentSource.title,
            showName: currentSource.showName || '',
            artworkUrl: currentSource.artworkUrl || '',
            link: currentSource.link || currentSource.url
          });
          // Don't set URL - keep input clear after loading
          // Restore saved position after audio loads
          setTimeout(() => {
            if (audioPlayerRef.current) {
              const savedPositions = JSON.parse(localStorage.getItem('harkenjot_media_positions') || '{}');
              const savedPosition = savedPositions[currentSource.id];
              if (savedPosition) {
                audioPlayerRef.current.currentTime = savedPosition;
              }
            }
          }, 500);
        } else {
          // Reset the ref when switching to a different type or no source
          lastInitializedSourceRef.current = null;
        }
      }, [currentSource]);

      // Check if Whisper is ready
      useEffect(() => {
        const checkWhisper = () => {
          if (window.WhisperASR?.isReady) {
            setWhisperReady(true);
          }
        };
        checkWhisper();
        const interval = setInterval(checkWhisper, 1000);
        return () => clearInterval(interval);
      }, []);

      // Initialize YouTube API
      useEffect(() => {
        if (!window.YT) {
          const tag = document.createElement('script');
          tag.src = 'https://www.youtube.com/iframe_api';
          const firstScriptTag = document.getElementsByTagName('script')[0];
          firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        }
      }, []);

      // Apply playback speed to YouTube and audio players
      useEffect(() => {
        if (playerRef.current && playerRef.current.setPlaybackRate) {
          playerRef.current.setPlaybackRate(speed);
        }
        if (audioPlayerRef.current) {
          audioPlayerRef.current.playbackRate = speed;
        }
      }, [speed]);

      // Save position whenever it changes (for both YouTube and podcast)
      useEffect(() => {
        if (currentSource?.id && (videoId || podcastAudio) && currentTime > 0) {
          const savedPositions = JSON.parse(localStorage.getItem('harkenjot_media_positions') || '{}');
          savedPositions[currentSource.id] = currentTime;
          localStorage.setItem('harkenjot_media_positions', JSON.stringify(savedPositions));
        }
      }, [currentTime, currentSource?.id, videoId, podcastAudio]);

      // Pause and save when page becomes hidden
      useEffect(() => {
        const handleVisibilityChange = () => {
          if (document.hidden && isPlaying && playerRef.current) {
            playerRef.current.pauseVideo();
            showToast('Playback paused - position saved');
          }
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);

        return () => {
          document.removeEventListener('visibilitychange', handleVisibilityChange);
          if (isPlaying && playerRef.current) {
            playerRef.current.pauseVideo();
          }
        };
      }, [isPlaying, showToast]);

      // Track playing state before car mode changes
      useEffect(() => {
        wasPlayingRef.current = isPlaying;
      }, [isPlaying]);

      // Resume YouTube playback after car mode changes if it was playing
      useEffect(() => {
        if (videoId && playerRef.current && wasPlayingRef.current) {
          // Small delay to let the DOM settle after car mode toggle
          const timer = setTimeout(() => {
            playerRef.current?.playVideo();
          }, 150);
          return () => clearTimeout(timer);
        }
      }, [carMode, videoId]);

      const extractVideoId = (url) => {
        const match = url.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/);
        return match ? match[1] : null;
      };

      // Detect URL type based on the actual URL
      const detectUrlType = (url) => {
        const lowerUrl = url.toLowerCase();
        // YouTube URLs
        if (lowerUrl.includes('youtube.com') || lowerUrl.includes('youtu.be')) {
          return 'youtube';
        }
        // Spotify URLs (will be converted to RSS)
        if (lowerUrl.includes('open.spotify.com') || lowerUrl.includes('spotify.com')) {
          return 'spotify';
        }
        // Direct audio file URLs
        if (lowerUrl.match(/\.(mp3|m4a|ogg|wav|aac)(\?|$)/)) {
          return 'audio';
        }
        // RSS feed URLs
        if (lowerUrl.includes('.xml') || lowerUrl.includes('/rss') || lowerUrl.includes('/feed') ||
            lowerUrl.includes('feeds.') || lowerUrl.includes('anchor.fm')) {
          return 'rss';
        }
        return null;
      };

      // Fetch Spotify metadata using oEmbed API
      const fetchSpotifyMetadata = async (spotifyUrl) => {
        try {
          const oembedUrl = `https://open.spotify.com/oembed?url=${encodeURIComponent(spotifyUrl)}`;
          const response = await fetch(oembedUrl);
          if (!response.ok) throw new Error('Failed to fetch Spotify metadata');
          const data = await response.json();
          return {
            title: data.title,
            showName: data.provider_name === 'Spotify' ? data.title.split(' - ')[0] : data.provider_name,
            thumbnailUrl: data.thumbnail_url
          };
        } catch (error) {
          console.error('Spotify oEmbed error:', error);
          return null;
        }
      };

      // Search for RSS feed using podcast name
      const searchForRSSFeed = async (showName, episodeTitle) => {
        try {
          // Use iTunes Search API to find podcast RSS feed
          const searchQuery = encodeURIComponent(showName);
          const response = await fetch(`https://itunes.apple.com/search?term=${searchQuery}&media=podcast&limit=5`);
          if (!response.ok) throw new Error('iTunes search failed');
          const data = await response.json();

          if (data.results && data.results.length > 0) {
            // Return the first matching podcast's feed URL
            return {
              feedUrl: data.results[0].feedUrl,
              podcastName: data.results[0].collectionName,
              artworkUrl: data.results[0].artworkUrl600 || data.results[0].artworkUrl100
            };
          }
          return null;
        } catch (error) {
          console.error('RSS search error:', error);
          return null;
        }
      };

      // Parse RSS feed and find episode
      const parseRSSAndFindEpisode = async (feedUrl, episodeTitle) => {
        try {
          // Use a CORS proxy for RSS feeds
          const corsProxy = 'https://api.allorigins.win/raw?url=';
          const response = await fetch(corsProxy + encodeURIComponent(feedUrl));
          if (!response.ok) throw new Error('Failed to fetch RSS feed');
          const xmlText = await response.text();

          const parser = new DOMParser();
          const xml = parser.parseFromString(xmlText, 'text/xml');
          const items = xml.querySelectorAll('item');

          // Extract channel artwork
          const channel = xml.querySelector('channel');
          const itunesImage = channel?.getElementsByTagName('itunes:image')[0];
          const channelArtwork = itunesImage?.getAttribute('href') ||
                                 channel?.querySelector('image url')?.textContent || '';

          // Try to find matching episode by title
          let bestMatch = null;
          let bestScore = 0;

          const normalizeTitle = (t) => t.toLowerCase().replace(/[^a-z0-9]/g, '');
          const targetTitle = normalizeTitle(episodeTitle);

          items.forEach((item, index) => {
            const title = item.querySelector('title')?.textContent || '';
            const enclosure = item.querySelector('enclosure');
            const audioUrl = enclosure?.getAttribute('url');

            if (audioUrl) {
              // Score based on title similarity
              const itemTitle = normalizeTitle(title);
              let score = 0;

              // Check for substring match
              if (itemTitle.includes(targetTitle) || targetTitle.includes(itemTitle)) {
                score = 100;
              } else {
                // Count matching words
                const targetWords = targetTitle.split(/\s+/);
                const itemWords = itemTitle.split(/\s+/);
                targetWords.forEach(word => {
                  if (word.length > 3 && itemTitle.includes(word)) score += 10;
                });
              }

              // Prefer first match if scores are equal (usually most recent)
              if (score > bestScore || (score === bestScore && !bestMatch)) {
                bestScore = score;

                const description = item.querySelector('description')?.textContent || '';

                bestMatch = {
                  title: title,
                  audioUrl: audioUrl,
                  description: description,
                  artworkUrl: channelArtwork,
                  pubDate: item.querySelector('pubDate')?.textContent || '',
                  link: item.querySelector('link')?.textContent || ''
                };
              }
            }
          });

          // If no good match, return first episode with audio
          if (!bestMatch && items.length > 0) {
            const firstItem = items[0];
            const enclosure = firstItem.querySelector('enclosure');
            if (enclosure?.getAttribute('url')) {
              const description = firstItem.querySelector('description')?.textContent || '';

              bestMatch = {
                title: firstItem.querySelector('title')?.textContent || 'Unknown Episode',
                audioUrl: enclosure.getAttribute('url'),
                description: description,
                artworkUrl: channelArtwork,
                pubDate: firstItem.querySelector('pubDate')?.textContent || '',
                link: firstItem.querySelector('link')?.textContent || ''
              };
            }
          }

          return bestMatch;
        } catch (error) {
          console.error('RSS parse error:', error);
          return null;
        }
      };

      // Load podcast from Spotify URL
      const loadPodcastFromSpotify = async () => {
        setIsLoadingPodcast(true);
        showToast('Searching for podcast feed...');

        try {
          // Step 1: Get Spotify metadata
          const metadata = await fetchSpotifyMetadata(url);
          if (!metadata) {
            showToast('Could not fetch Spotify metadata');
            setIsLoadingPodcast(false);
            return;
          }

          showToast(`Found: ${metadata.title}`);

          // Step 2: Search for RSS feed
          const rssInfo = await searchForRSSFeed(metadata.showName, metadata.title);
          if (!rssInfo) {
            showToast('Could not find RSS feed for this podcast');
            setIsLoadingPodcast(false);
            return;
          }

          showToast(`Found feed: ${rssInfo.podcastName}`);

          // Step 3: Parse RSS and find episode
          const episode = await parseRSSAndFindEpisode(rssInfo.feedUrl, metadata.title);
          if (!episode) {
            showToast('Could not find episode in RSS feed');
            setIsLoadingPodcast(false);
            return;
          }

          // Success! Load the audio
          setVideoId(null);
          setPodcastAudio({
            audioUrl: episode.audioUrl,
            title: episode.title,
            showName: rssInfo.podcastName,
            artworkUrl: rssInfo.artworkUrl,
            link: episode.link || url
          });

          addSource({
            type: 'podcast',
            title: episode.title,
            url: url,
            audioUrl: episode.audioUrl,
            showName: rssInfo.podcastName,
            artworkUrl: rssInfo.artworkUrl,
            link: episode.link || url
          });

          setUrl(''); // Clear URL after successful load
          showToast('Podcast loaded!');
        } catch (error) {
          console.error('Podcast loading error:', error);
          showToast('Failed to load podcast');
        }

        setIsLoadingPodcast(false);
      };

      // Load direct RSS feed
      const loadRSSFeed = async (feedUrl) => {
        setIsLoadingPodcast(true);
        showToast('Loading RSS feed...');

        try {
          const episode = await parseRSSAndFindEpisode(feedUrl, '');
          if (!episode) {
            showToast('Could not find episodes in RSS feed');
            setIsLoadingPodcast(false);
            return;
          }

          setVideoId(null);
          setPodcastAudio({
            audioUrl: episode.audioUrl,
            title: episode.title,
            showName: 'Podcast',
            artworkUrl: episode.artworkUrl || '',
            link: episode.link || feedUrl
          });

          addSource({
            type: 'podcast',
            title: episode.title,
            url: feedUrl,
            audioUrl: episode.audioUrl,
            artworkUrl: episode.artworkUrl || '',
            link: episode.link || feedUrl
          });

          setUrl(''); // Clear URL after successful load
          showToast('Podcast loaded!');
        } catch (error) {
          showToast('Failed to load RSS feed');
        }

        setIsLoadingPodcast(false);
      };

      const loadMedia = async () => {
        const urlType = detectUrlType(url);

        if (urlType === 'youtube') {
          const id = extractVideoId(url);
          if (!id) {
            showToast('Invalid YouTube URL');
            return;
          }

          setVideoId(id);
          setPodcastAudio(null);

          // Fetch YouTube title and channel via oEmbed API
          let videoTitle = 'YouTube Video';
          let channelName = '';
          try {
            const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
            const response = await fetch(oembedUrl);
            if (response.ok) {
              const data = await response.json();
              videoTitle = data.title || 'YouTube Video';
              channelName = data.author_name || '';
            }
          } catch (err) {
            console.log('Could not fetch YouTube metadata:', err);
          }

          addSource({
            type: 'youtube',
            title: videoTitle,
            url: url,
            videoId: id,
            channelName: channelName
          });

          setUrl(''); // Clear URL after successful load

          // Initialize player after state update
          setTimeout(() => {
            if (window.YT && window.YT.Player) {
              initPlayer(id);
            } else {
              window.onYouTubeIframeAPIReady = () => initPlayer(id);
            }
          }, 100);
        } else if (urlType === 'spotify') {
          loadPodcastFromSpotify();
        } else if (urlType === 'rss') {
          loadRSSFeed(url);
        } else if (urlType === 'audio') {
          // Direct audio URL
          setVideoId(null);
          setPodcastAudio({
            audioUrl: url,
            title: 'Audio',
            showName: ''
          });
          addSource({
            type: 'podcast',
            title: 'Audio',
            url: url,
            audioUrl: url
          });
          setUrl(''); // Clear URL after successful load
          showToast('Audio loaded');
        } else {
          showToast('Please enter a YouTube, Spotify, or RSS feed URL');
        }
      };

      // Text note functions
      const openTextNote = () => {
        // Store playback state and pause if playing
        if (isPlaying) {
          wasPlayingRef.current = true;
          if (audioPlayerRef.current) audioPlayerRef.current.pause();
          if (playerRef.current) playerRef.current.pauseVideo();
          setIsPlaying(false);
        } else {
          wasPlayingRef.current = false;
        }
        setShowTextNote(true);
      };

      const saveTextNote = () => {
        if (textNote.trim() && currentSource) {
          addNote({
            sourceId: currentSource.id,
            timestamp: currentTime,
            text: textNote.trim(),
            type: 'text'
          });
          showToast('Note saved');
        }
        setTextNote('');
        setShowTextNote(false);
        // Resume playback if it was playing
        if (wasPlayingRef.current) {
          if (audioPlayerRef.current) audioPlayerRef.current.play();
          if (playerRef.current) playerRef.current.playVideo();
        }
      };

      const cancelTextNote = () => {
        setTextNote('');
        setShowTextNote(false);
        // Resume playback if it was playing
        if (wasPlayingRef.current) {
          if (audioPlayerRef.current) audioPlayerRef.current.play();
          if (playerRef.current) playerRef.current.playVideo();
        }
      };

      // Wake Lock helpers to keep screen on during playback
      const requestWakeLock = async () => {
        try {
          if ('wakeLock' in navigator) {
            // Release old wake lock if it exists
            if (wakeLockRef.current) {
              try {
                await wakeLockRef.current.release();
              } catch (e) {
                // Ignore errors from releasing
              }
            }

            // Always request fresh wake lock (handles screen on/off cycles)
            wakeLockRef.current = await navigator.wakeLock.request('screen');
            console.log('Wake Lock activated');

            // Listen for release event to clear the ref
            wakeLockRef.current.addEventListener('release', () => {
              console.log('Wake Lock was released');
              wakeLockRef.current = null;
            });
          }
        } catch (err) {
          console.log('Wake Lock not supported or failed:', err);
          wakeLockRef.current = null;
        }
      };

      const releaseWakeLock = async () => {
        try {
          if (wakeLockRef.current) {
            await wakeLockRef.current.release();
            wakeLockRef.current = null;
            console.log('Wake Lock released');
          }
        } catch (err) {
          console.log('Wake Lock release failed:', err);
        }
      };

      const initPlayer = (id) => {
        if (playerRef.current && playerRef.current.destroy) {
          playerRef.current.destroy();
        }

        playerRef.current = new window.YT.Player('youtube-player', {
          videoId: id,
          playerVars: {
            autoplay: 0,
            controls: 1,
            modestbranding: 1,
            rel: 0
          },
          events: {
            onReady: (event) => {
              const dur = event.target.getDuration();
              setDuration(dur);
              // Update source with duration for Library display
              if (currentSource?.id && dur && isFinite(dur)) {
                updateSource(currentSource.id, { duration: dur });
              }
            },
            onStateChange: (event) => {
              setIsPlaying(event.data === window.YT.PlayerState.PLAYING);

              if (event.data === window.YT.PlayerState.PLAYING) {
                requestWakeLock(); // Keep screen on while playing
                intervalRef.current = setInterval(() => {
                  setCurrentTime(playerRef.current.getCurrentTime());
                }, 500);
              } else {
                releaseWakeLock(); // Release when paused/stopped
                clearInterval(intervalRef.current);
              }
            }
          }
        });
      };

      const togglePlayback = () => {
        if (!playerRef.current) return;

        if (isPlaying) {
          playerRef.current.pauseVideo();
        } else {
          playerRef.current.playVideo();
        }
      };

      const skipTime = (seconds) => {
        if (!playerRef.current) return;
        const wasPlaying = isPlaying;
        const newTime = Math.max(0, Math.min(duration, currentTime + seconds));
        playerRef.current.seekTo(newTime, true);
        setCurrentTime(newTime);
        // Resume playback if it was playing before seek
        if (wasPlaying) {
          setTimeout(() => playerRef.current?.playVideo(), 100);
        }
      };

      const stopRecording = () => {
        if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
          playSound('stop');
          mediaRecorderRef.current.stop();
        }

        // Clean up audio context
        if (audioContextRef.current) {
          try {
            audioContextRef.current.close();
          } catch (err) {
            console.log('Error closing audio context:', err);
          }
          audioContextRef.current = null;
        }

        // Clear silence timeout
        if (silenceTimeoutRef.current) {
          clearTimeout(silenceTimeoutRef.current);
          silenceTimeoutRef.current = null;
        }
      };

      const handleVoiceButtonClick = () => {
        if (isRecording) {
          stopRecording();
        } else if (isTranscribing) {
          // Provide feedback that we're busy transcribing
          playSound('error');
          showToast('Still processing previous recording...');
        } else if (isStartingRecordingRef.current) {
          // Prevent concurrent startRecording calls
          playSound('error');
          showToast('Please wait, starting recording...');
        } else {
          startRecording();
        }
      };

      const startRecording = async () => {
        if (!whisperReady) {
          playSound('error');
          showToast('Speech recognition still loading. Please wait.');
          return;
        }

        // Prevent race condition from multiple rapid clicks
        if (isStartingRecordingRef.current) {
          return;
        }
        isStartingRecordingRef.current = true;

        // Clean up any existing recording state
        stopRecording();

        if (isPlaying && playerRef.current) {
          playerRef.current.pauseVideo();
        }

        const recordingTime = currentTime;

        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          audioChunksRef.current = [];

          const mimeType = window.WhisperASR?.getSupportedMimeType() || '';
          const mediaRecorder = mimeType
            ? new MediaRecorder(stream, { mimeType })
            : new MediaRecorder(stream);
          mediaRecorderRef.current = mediaRecorder;

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunksRef.current.push(event.data);
            }
          };

          mediaRecorder.onerror = (event) => {
            console.error('MediaRecorder error:', event.error);
            showToast('Recording error. Try again.');
            stream.getTracks().forEach(track => track.stop());
            setIsRecording(false);
          };

          mediaRecorder.onstop = async () => {
            // Clean up audio context and timers
            if (audioContextRef.current) {
              audioContextRef.current.close();
              audioContextRef.current = null;
            }
            if (silenceTimeoutRef.current) {
              clearTimeout(silenceTimeoutRef.current);
              silenceTimeoutRef.current = null;
            }

            stream.getTracks().forEach(track => track.stop());

            if (audioChunksRef.current.length === 0) {
              playSound('error');
              showToast('No audio captured. Try again.');
              setIsRecording(false);
              return;
            }

            const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });

            if (audioBlob.size < 500) {
              playSound('error');
              showToast('Recording too short. Try again.');
              setIsRecording(false);
              return;
            }

            // Transition from recording to transcribing
            setIsRecording(false);
            setIsTranscribing(true);

            try {
              const transcript = await window.WhisperASR.transcribe(audioBlob);
              if (transcript && transcript.trim()) {
                addNote({
                  sourceId: currentSource?.id,
                  text: transcript.trim(),
                  timestamp: recordingTime,
                  type: 'voice'
                });
                playSound('success');
                showToast('Note saved!');
              } else {
                playSound('error');
                showToast('No speech detected - try speaking louder');
              }
            } catch (error) {
              console.error('Transcription failed:', error);
              playSound('error');
              showToast('Transcription failed. Try again.');
            }
            setIsTranscribing(false);
          };

          mediaRecorder.start(100);
          setIsRecording(true);
          isStartingRecordingRef.current = false; // Recording started successfully
          playSound('start');
          showToast('Listening...');

            // Set up voice activity detection for auto-stop
            try {
              const audioContext = new (window.AudioContext || window.webkitAudioContext)();
              audioContextRef.current = audioContext;

              const source = audioContext.createMediaStreamSource(stream);
              const analyzer = audioContext.createAnalyser();
              analyzer.fftSize = 2048;
              analyzer.smoothingTimeConstant = 0.8;
              source.connect(analyzer);
              analyzerRef.current = analyzer;

              const dataArray = new Uint8Array(analyzer.frequencyBinCount);
              const frequencyData = new Uint8Array(analyzer.frequencyBinCount);
              const recordingStartTime = Date.now();
              let lastSoundTime = Date.now();
              let gracePeriodEnded = false;
              const SILENCE_DURATION = 2500; // 2.5 seconds of silence before auto-stop
              const GRACE_PERIOD = 2000; // 2 seconds grace period before checking for silence

              const checkAudioLevel = () => {
                if (!mediaRecorderRef.current || mediaRecorderRef.current.state !== 'recording') {
                  return;
                }

                const elapsed = Date.now() - recordingStartTime;
                const inGracePeriod = elapsed < GRACE_PERIOD;

                // Reset lastSoundTime when grace period ends (only once)
                if (!inGracePeriod && !gracePeriodEnded) {
                  lastSoundTime = Date.now();
                  gracePeriodEnded = true;
                }

                // Get frequency data for voice detection
                analyzer.getByteFrequencyData(frequencyData);

                // Voice typically exists in 85Hz - 4000Hz range
                // Calculate which frequency bins correspond to this range
                const sampleRate = audioContext.sampleRate;
                const binCount = analyzer.frequencyBinCount;
                const binSize = sampleRate / (binCount * 2);

                const voiceStartBin = Math.floor(85 / binSize);
                const voiceEndBin = Math.floor(4000 / binSize);

                // Calculate average energy in voice frequency range
                let voiceEnergy = 0;
                let voiceBinCount = 0;
                for (let i = voiceStartBin; i < voiceEndBin && i < binCount; i++) {
                  voiceEnergy += frequencyData[i];
                  voiceBinCount++;
                }
                const avgVoiceEnergy = voiceBinCount > 0 ? voiceEnergy / voiceBinCount : 0;

                // Also check overall amplitude for additional confidence
                analyzer.getByteTimeDomainData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                  const amplitude = Math.abs(dataArray[i] - 128);
                  sum += amplitude;
                }
                const avgAmplitude = sum / dataArray.length;

                // Voice detected if there's energy in voice frequencies AND sufficient amplitude
                // These thresholds are more Google-like: higher and more selective
                const VOICE_ENERGY_THRESHOLD = 30; // Energy in voice frequency range (0-255)
                const AMPLITUDE_THRESHOLD = 8; // Overall amplitude (0-127)

                const isVoiceDetected = avgVoiceEnergy > VOICE_ENERGY_THRESHOLD && avgAmplitude > AMPLITUDE_THRESHOLD;

                // If voice detected, reset silence timer
                if (isVoiceDetected) {
                  lastSoundTime = Date.now();
                  if (silenceTimeoutRef.current) {
                    clearTimeout(silenceTimeoutRef.current);
                    silenceTimeoutRef.current = null;
                  }
                } else if (!inGracePeriod) {
                  // Only check for auto-stop AFTER grace period
                  const silenceDuration = Date.now() - lastSoundTime;
                  if (silenceDuration > SILENCE_DURATION && !silenceTimeoutRef.current) {
                    // Auto-stop recording after silence
                    console.log('Auto-stopping recording after silence');
                    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                      setIsRecording(false);
                      mediaRecorderRef.current.stop();
                    }
                    if (audioContextRef.current) {
                      audioContextRef.current.close();
                      audioContextRef.current = null;
                    }
                    return; // Stop checking
                  }
                }

                // Continue checking
                requestAnimationFrame(checkAudioLevel);
              };

              // Start monitoring audio levels
              checkAudioLevel();
            } catch (err) {
              console.log('Voice activity detection setup failed:', err);
              // Continue recording without auto-stop if VAD fails
            }
          } catch (error) {
            console.error('Failed to start recording:', error);
            playSound('error');
            showToast('Microphone access denied or unavailable');
            setIsRecording(false);
            isStartingRecordingRef.current = false; // Failed to start
            // Clean up any partial setup
            if (audioContextRef.current) {
              try {
                audioContextRef.current.close();
              } catch (err) {}
              audioContextRef.current = null;
            }
          }
      };

      const progress = duration ? (currentTime / duration) * 100 : 0;

      return (
        <div style={{ display: 'flex', flexDirection: 'column', flex: 1, minHeight: 0, overflow: 'hidden' }}>
          <div className="input-section" style={{ display: carMode ? 'none' : 'block' }}>
            <div className="input-group">
              <input
                type="text"
                className="url-input"
                placeholder="Paste YouTube or podcast link..."
                value={url}
                onChange={(e) => setUrl(e.target.value)}
              />
              <button className="btn btn-primary" onClick={loadMedia} disabled={isLoadingPodcast}>
                {isLoadingPodcast ? 'Loading...' : <><Icons.Link /> Load</>}
              </button>
            </div>
          </div>

          {videoId ? (
            <div className="media-container">
              {currentSource && (
                <div className="reader-header">
                  <div className="source-info">
                    <h2>{currentSource.title || 'YouTube Video'}</h2>
                    <div className="source-meta">
                      <span className="library-item-type youtube">YouTube</span>
                      {currentSource.channelName && <span>{currentSource.channelName}</span>}
                      {duration > 0 && <span>{formatTime(duration)}</span>}
                      {currentSource.url && <a href={currentSource.url} target="_blank" rel="noopener noreferrer"><Icons.Link /></a>}
                    </div>
                  </div>
                </div>
              )}
              <div className="youtube-container" style={carMode ? { position: 'absolute', width: '1px', height: '1px', opacity: 0, pointerEvents: 'none' } : {}}>
                <div id="youtube-player"></div>
              </div>

              {showTextNote && (
                <div className="text-note-container">
                  <input
                    type="text"
                    className="url-input text-note-input"
                    placeholder="Type your note..."
                    value={textNote}
                    onChange={(e) => setTextNote(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && saveTextNote()}
                    autoFocus
                  />
                  <div className="text-note-buttons">
                    <button className="btn btn-primary" onClick={saveTextNote}>Save</button>
                    <button className="btn btn-secondary" onClick={cancelTextNote}>Cancel</button>
                  </div>
                </div>
              )}

              <div className={`playback-bar ${carMode ? 'car-mode' : ''}`}>
                <div className="playback-controls">
                  <div className="transport-buttons">
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={() => skipTime(-15)}
                      title="Back 15 seconds"
                    >
                      <Icons.Rewind />
                      <span style={{ fontSize: '0.65rem', marginLeft: '2px' }}>15</span>
                    </button>
                    <button className={`play-btn ${carMode ? 'car-mode' : ''}`} onClick={togglePlayback}>
                      {isPlaying ? <Icons.Pause /> : <Icons.Play />}
                    </button>
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={() => skipTime(15)}
                      title="Forward 15 seconds"
                    >
                      <span style={{ fontSize: '0.65rem', marginRight: '2px' }}>15</span>
                      <Icons.FastForward />
                    </button>
                  </div>

                  <div className={`progress-speed-group ${carMode ? 'car-mode' : ''}`}>
                    <div className="progress-container">
                      <div className={`progress-bar ${carMode ? 'car-mode' : ''}`}>
                        <div className="progress-fill" style={{ width: `${progress}%` }} />
                      </div>
                      <div className="progress-text">
                        <span>{formatTime(currentTime)}</span>
                        <span>{formatTime(duration)}</span>
                      </div>
                    </div>

                    <div className={`speed-control ${carMode ? 'car-mode' : ''}`}>
                      <label>Speed</label>
                      <select value={speed} onChange={(e) => setSpeed(parseFloat(e.target.value))}>
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1">1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                      </select>
                    </div>
                  </div>
                </div>

                <div className="note-controls">
                  <button
                    className={`note-btn ${isProcessing ? 'processing' : ''} ${carMode ? 'car-mode' : ''}`}
                    onClick={handleVoiceButtonClick}
                    disabled={false}
                  >
                    {isRecording ? ' Stop' :
                     isTranscribing ? 'Processing...' :
                     <><Icons.Mic /> Voice</>}
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    onClick={openTextNote}
                  >
                    <Icons.Keyboard /> Type
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    disabled={true}
                    title="Search not available for YouTube"
                    style={{ opacity: 0.5 }}
                  >
                    <Icons.Search /> Search
                  </button>
                  {isMobileDevice && (
                    <button
                      className={`note-btn ${carMode ? 'car-mode active' : ''}`}
                      onClick={() => setCarMode(!carMode)}
                      title="Car Mode"
                    >
                      <Icons.Car />
                    </button>
                  )}
                </div>
              </div>
            </div>
          ) : podcastAudio ? (
            <div className="reader-container">
              <div className="reader-header">
                <div className="source-info">
                  <h2>{podcastAudio.title}</h2>
                  <div className="source-meta">
                    <span className="library-item-type podcast">Podcast</span>
                    {podcastAudio.showName && <span>{podcastAudio.showName}</span>}
                    <span>{formatTime(duration)}</span>
                    {podcastAudio.link && <a href={podcastAudio.link} target="_blank" rel="noopener noreferrer"><Icons.Link /></a>}
                  </div>
                </div>
              </div>

              {podcastAudio.artworkUrl && !carMode && (
                <div style={{ display: 'flex', justifyContent: 'center', padding: '1rem' }}>
                  <img
                    src={podcastAudio.artworkUrl}
                    alt="Podcast artwork"
                    style={{ width: '200px', height: '200px', borderRadius: '12px', boxShadow: '0 4px 12px rgba(0,0,0,0.15)' }}
                  />
                </div>
              )}

              {/* Spacer to allow flex shrinking when text note appears - hidden in car mode */}
              <div style={{ flex: 1, minHeight: 0, display: carMode ? 'none' : 'block' }} />

              <audio
                ref={audioPlayerRef}
                src={podcastAudio.audioUrl}
                onTimeUpdate={(e) => setCurrentTime(e.target.currentTime)}
                onDurationChange={(e) => {
                  const dur = e.target.duration;
                  setDuration(dur);
                  // Update source with duration for Library display
                  if (currentSource?.id && dur && isFinite(dur)) {
                    updateSource(currentSource.id, { duration: dur });
                  }
                }}
                onPlay={() => setIsPlaying(true)}
                onPause={() => setIsPlaying(false)}
                style={{ display: 'none' }}
              />

              {showTextNote && (
                <div className="text-note-container">
                  <input
                    type="text"
                    className="url-input text-note-input"
                    placeholder="Type your note..."
                    value={textNote}
                    onChange={(e) => setTextNote(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && saveTextNote()}
                    autoFocus
                  />
                  <div className="text-note-buttons">
                    <button className="btn btn-primary" onClick={saveTextNote}>Save</button>
                    <button className="btn btn-secondary" onClick={cancelTextNote}>Cancel</button>
                  </div>
                </div>
              )}

              <div className={`playback-bar ${carMode ? 'car-mode' : ''}`}>
                <div className="playback-controls">
                  <div className="transport-buttons">
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={() => { if (audioPlayerRef.current) audioPlayerRef.current.currentTime -= 15; }}
                      title="Back 15 seconds"
                    >
                      <Icons.Rewind />
                      <span style={{ fontSize: '0.65rem', marginLeft: '2px' }}>15</span>
                    </button>
                    <button className={`play-btn ${carMode ? 'car-mode' : ''}`} onClick={() => {
                      if (audioPlayerRef.current) {
                        if (isPlaying) {
                          audioPlayerRef.current.pause();
                        } else {
                          audioPlayerRef.current.play();
                        }
                      }
                    }}>
                      {isPlaying ? <Icons.Pause /> : <Icons.Play />}
                    </button>
                    <button
                      className={`skip-btn ${carMode ? 'car-mode' : ''}`}
                      onClick={() => { if (audioPlayerRef.current) audioPlayerRef.current.currentTime += 15; }}
                      title="Forward 15 seconds"
                    >
                      <span style={{ fontSize: '0.65rem', marginRight: '2px' }}>15</span>
                      <Icons.FastForward />
                    </button>
                  </div>

                  <div className={`progress-speed-group ${carMode ? 'car-mode' : ''}`}>
                    <div className="progress-container">
                      <div className={`progress-bar ${carMode ? 'car-mode' : ''}`} onClick={(e) => {
                        if (audioPlayerRef.current && duration) {
                          const rect = e.currentTarget.getBoundingClientRect();
                          const percent = (e.clientX - rect.left) / rect.width;
                          audioPlayerRef.current.currentTime = percent * duration;
                        }
                      }} style={{ cursor: 'pointer' }}>
                        <div className="progress-fill" style={{ width: `${progress}%` }} />
                      </div>
                      <div className="progress-text">
                        <span>{formatTime(currentTime)}</span>
                        <span>{formatTime(duration)}</span>
                      </div>
                    </div>

                    <div className={`speed-control ${carMode ? 'car-mode' : ''}`}>
                      <label>Speed</label>
                      <select value={speed} onChange={(e) => setSpeed(parseFloat(e.target.value))}>
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1">1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                      </select>
                    </div>
                  </div>
                </div>

                <div className="note-controls">
                  <button
                    className={`note-btn ${isProcessing ? 'processing' : ''} ${carMode ? 'car-mode' : ''}`}
                    onClick={handleVoiceButtonClick}
                    disabled={false}
                  >
                    {isRecording ? ' Stop' :
                     isTranscribing ? 'Processing...' :
                     <><Icons.Mic /> Voice</>}
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    onClick={openTextNote}
                  >
                    <Icons.Keyboard /> Type
                  </button>
                  <button
                    className={`note-btn ${carMode ? 'car-mode' : ''}`}
                    disabled={true}
                    title="Search not available for podcasts"
                    style={{ opacity: 0.5 }}
                  >
                    <Icons.Search /> Search
                  </button>
                  {isMobileDevice && (
                    <button
                      className={`note-btn ${carMode ? 'car-mode active' : ''}`}
                      onClick={() => setCarMode(!carMode)}
                      title="Car Mode"
                    >
                      <Icons.Car />
                    </button>
                  )}
                </div>
              </div>
            </div>
          ) : (
            <div className="empty-state">
              <div className="empty-state-icon"></div>
              <h3>Media Player</h3>
              <p>Paste a YouTube, Spotify, or podcast RSS link above to begin. The app will play it and let you take notes while you listen.</p>
            </div>
          )}
        </div>
      );
    });

    // Library View Component
    function LibraryView({ sources, notes, setCurrentSource, openSourceWithNotes, deleteNote, deleteSource, setSources, setNotes, showToast }) {
      const groupedSources = sources.reduce((acc, source) => {
        const date = new Date(source.createdAt).toDateString();
        if (!acc[date]) acc[date] = [];
        acc[date].push(source);
        return acc;
      }, {});

      const getNotesForSource = (sourceId) => notes.filter(n => n.sourceId === sourceId);

      const exportToOneNote = () => {
        const getFirstThreeWords = (text) => {
          if (!text) return '';
          const words = text.trim().split(/\s+/).slice(0, 3);
          return words.join(' ');
        };

        let exportText = '';
        let firstSource = true;

        Object.entries(groupedSources).forEach(([date, dateSources]) => {
          dateSources.forEach(source => {
            const sourceNotes = getNotesForSource(source.id);
            if (sourceNotes.length > 0) {
              // Add blank line between sources (except before first)
              if (!firstSource) {
                exportText += '\n';
              }
              firstSource = false;

              exportText += `${source.title} (${source.url || source.link || ''})\n`;
              exportText += 'Notes:\n';
              sourceNotes.forEach(note => {
                let notePrefix = '';
                if (note.timestamp !== undefined) {
                  notePrefix = `[${formatTime(note.timestamp)}] `;
                } else if (note.position !== undefined && note.context) {
                  const firstThree = getFirstThreeWords(note.context);
                  notePrefix = `[Sentence ${note.position + 1} "${firstThree}..."] `;
                }
                exportText += `- ${notePrefix}${note.text}\n`;
              });
            }
          });
        });

        navigator.clipboard.writeText(exportText);
      };

      const exportLibrary = () => {
        // Include saved positions for articles/PDFs and media
        const readerPositions = JSON.parse(localStorage.getItem('harkenjot_positions') || '{}');
        const mediaPositions = JSON.parse(localStorage.getItem('harkenjot_media_positions') || '{}');

        const exportData = {
          version: 2,
          exportedAt: new Date().toISOString(),
          sources: sources,
          notes: notes,
          positions: {
            reader: readerPositions,
            media: mediaPositions
          }
        };

        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `harkenjot-library-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('Library exported');
      };

      const importLibrary = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const data = JSON.parse(event.target.result);

              if (!data.sources || !data.notes) {
                showToast('Invalid library file');
                return;
              }

              if (!confirm(`Import ${data.sources.length} sources and ${data.notes.length} notes? This will replace your current library.`)) {
                return;
              }

              setSources(data.sources);
              setNotes(data.notes);

              // Restore saved positions if available (version 2+)
              if (data.positions) {
                if (data.positions.reader) {
                  localStorage.setItem('harkenjot_positions', JSON.stringify(data.positions.reader));
                }
                if (data.positions.media) {
                  localStorage.setItem('harkenjot_media_positions', JSON.stringify(data.positions.media));
                }
              }

              showToast(`Imported ${data.sources.length} sources and ${data.notes.length} notes`);
            } catch (err) {
              showToast('Failed to import library');
            }
          };
          reader.readAsText(file);
        };
        input.click();
      };

      return (
        <div style={{ display: 'flex', flexDirection: 'column', flex: 1, minHeight: 0, overflow: 'hidden' }}>
          <div className="library-actions">
            <button className="btn btn-secondary" onClick={exportToOneNote}>
              <Icons.Copy /> Copy All
            </button>
            <button className="btn btn-secondary" onClick={importLibrary} title="Import Library">
              <Icons.FolderDown /> Import All
            </button>
            <button className="btn btn-secondary" onClick={exportLibrary} title="Export Library">
              <Icons.FolderUp /> Export All
            </button>
          </div>

          {sources.length === 0 ? (
            <div className="empty-state">
              <div className="empty-state-icon"></div>
              <h3>Library Empty</h3>
              <p>Your sources and notes will appear here. Start by adding an article or podcast in the Reader or Player tabs.</p>
            </div>
          ) : (
            <div className="library-grid" style={{ flex: 1, overflow: 'auto' }}>
              {Object.entries(groupedSources).map(([date, dateSources]) => (
                <div key={date} className="library-date-group">
                  <div className="date-header">{formatDate(new Date(date))}</div>
                  {dateSources.map(source => (
                    <div
                      key={source.id}
                      className="library-item"
                      onClick={() => setCurrentSource(source)}
                    >
                      <div className="library-item-top">
                        <div className="library-item-title">{source.title}</div>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', flexShrink: 0 }}>
                          <div
                            className="note-count"
                            onClick={(e) => {
                              e.stopPropagation();
                              openSourceWithNotes(source);
                            }}
                            style={{ cursor: 'pointer' }}
                            title="Open source and view notes"
                          >
                            <Icons.Pencil />
                            {getNotesForSource(source.id).length} notes
                          </div>
                          <button
                            className="note-action-btn delete"
                            onClick={(e) => {
                              e.stopPropagation();
                              if (confirm('Delete this item and all its notes?')) {
                                deleteSource(source.id);
                              }
                            }}
                            title="Delete item"
                          >
                            <Icons.Trash />
                          </button>
                        </div>
                      </div>
                      <div className="library-item-meta">
                        <span className={`library-item-type ${source.type}`}>{source.type}</span>
                        {source.type === 'podcast' && source.showName && <span>{source.showName}</span>}
                        {source.type === 'youtube' && source.channelName && <span>{source.channelName}</span>}
                        {source.type !== 'podcast' && source.type !== 'youtube' && source.url && <span style={{ maxWidth: '200px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{new URL(source.url).hostname}</span>}
                        {(source.type === 'podcast' || source.type === 'youtube') && <span>{source.duration ? formatTime(source.duration) : ''}</span>}
                        {(source.type === 'article' || source.type === 'pdf') && source.sentences && <span>{source.sentences.length} sentences</span>}
                        {(source.url || source.link) && <a href={source.link || source.url} target="_blank" rel="noopener noreferrer" onClick={(e) => e.stopPropagation()}><Icons.Link /></a>}
                      </div>
                    </div>
                  ))}
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }

    // Note Sidebar Component
    function NoteSidebar({ notes, currentSource, deleteNote, updateNote, navigateToNote, showToast, onClose }) {
      const [editingNoteId, setEditingNoteId] = useState(null);
      const [editText, setEditText] = useState('');

      const startEdit = (note) => {
        setEditingNoteId(note.id);
        setEditText(note.text);
      };

      const cancelEdit = () => {
        setEditingNoteId(null);
        setEditText('');
      };

      const saveEdit = (noteId) => {
        if (editText.trim()) {
          updateNote(noteId, editText.trim());
          setEditingNoteId(null);
          setEditText('');
        }
      };

      const copyNote = (note) => {
        const getFirstThreeWords = (text) => {
          if (!text) return '';
          const words = text.trim().split(/\s+/).slice(0, 3);
          return words.join(' ');
        };

        let notePrefix = '';
        if (note.timestamp !== undefined) {
          notePrefix = `[${formatTime(note.timestamp)}] `;
        } else if (note.position !== undefined && note.context) {
          const firstThree = getFirstThreeWords(note.context);
          notePrefix = `[Sentence ${note.position + 1} "${firstThree}..."] `;
        }

        const noteText = `${currentSource.title} (${currentSource.url || currentSource.link || ''})\nNotes:\n- ${notePrefix}${note.text}`;
        navigator.clipboard.writeText(noteText);
        showToast('Note copied to clipboard');
      };

      const exportAllNotes = () => {
        if (!currentSource || notes.length === 0) return;

        const getFirstThreeWords = (text) => {
          if (!text) return '';
          const words = text.trim().split(/\s+/).slice(0, 3);
          return words.join(' ');
        };

        let exportText = `${currentSource.title} (${currentSource.url || currentSource.link || ''})\nNotes:\n`;
        notes.forEach(note => {
          let notePrefix = '';
          if (note.timestamp !== undefined) {
            notePrefix = `[${formatTime(note.timestamp)}] `;
          } else if (note.position !== undefined && note.context) {
            const firstThree = getFirstThreeWords(note.context);
            notePrefix = `[Sentence ${note.position + 1} "${firstThree}..."] `;
          }
          exportText += `- ${notePrefix}${note.text}\n`;
        });

        navigator.clipboard.writeText(exportText);
        showToast('All notes copied to clipboard');
      };

      return (
        <div>
          <div className="sidebar-title" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <span><Icons.Pencil /> Notes ({notes.length})</span>
            {onClose && (
              <button
                onClick={onClose}
                className="btn btn-secondary btn-icon"
                style={{ width: '32px', height: '32px', padding: 0 }}
              >
                <Icons.X />
              </button>
            )}
          </div>
          
          {notes.length === 0 ? (
            <div style={{ textAlign: 'center', padding: '2rem 1rem', color: 'var(--text-muted)' }}>
              <Icons.Mic />
              <p style={{ marginTop: '0.5rem', fontSize: '0.875rem' }}>
                Click "Add Note" while reading to record voice notes
              </p>
            </div>
          ) : (
            <div className="notes-list">
              {notes.map(note => (
                <div key={note.id} className="note-card">
                  <div
                    className="note-position"
                    onClick={() => navigateToNote(note)}
                    style={{ cursor: 'pointer' }}
                    title="Click to navigate to this location"
                  >
                    {note.timestamp !== undefined
                      ? formatTime(note.timestamp)
                      : `Sentence ${note.position + 1}`}
                  </div>

                  {editingNoteId === note.id ? (
                    // Edit mode
                    <>
                      <textarea
                        className="note-edit-input"
                        value={editText}
                        onChange={(e) => setEditText(e.target.value)}
                        autoFocus
                        rows="4"
                      />
                      <div className="note-actions">
                        <button className="note-action-btn" onClick={() => saveEdit(note.id)}>
                          Save
                        </button>
                        <button className="note-action-btn" onClick={cancelEdit}>
                          Cancel
                        </button>
                      </div>
                    </>
                  ) : (
                    // View mode
                    <>
                      <div className="note-text">{note.text}</div>
                      {note.context && (
                        <div className="note-context">"{note.context}"</div>
                      )}
                      <div className="note-actions">
                        <button className="note-action-btn" onClick={() => startEdit(note)}>
                          <Icons.Edit /> Edit
                        </button>
                        <button className="note-action-btn" onClick={() => copyNote(note)}>
                          <Icons.Copy /> Copy
                        </button>
                        <button className="note-action-btn delete" onClick={() => deleteNote(note.id)}>
                          <Icons.Trash /> Delete
                        </button>
                      </div>
                    </>
                  )}
                </div>
              ))}
            </div>
          )}

          {notes.length > 0 && (
            <div className="export-section">
              <button className="export-btn" onClick={exportAllNotes}>
                <Icons.Copy /> Copy Notes
              </button>
            </div>
          )}
        </div>
      );
    }

    // Render the app
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>